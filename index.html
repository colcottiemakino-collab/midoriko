<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ハンドレッド / Hundred v2.3.0</title>
<style>
  :root{
    --bg:#0e1a12; --bg2:#122216; --panel:#152a1b; --accent:#35c46e; --accent-2:#2aa55b;
    --text:#e7ffe7; --muted:#b9d8c0; --warn:#ffd37a; --bad:#ff8a8a; --good:#8affb9;
    --grid-used:#2a3a2f; --btn:#173d26; --btn-hover:#1f5333; --border:#2f6848;
  }
  *{box-sizing:border-box}
  body{margin:0; background:linear-gradient(180deg,var(--bg),var(--bg2)); color:var(--text);
    font-family:ui-sans-serif,system-ui,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif;}
  header{padding:18px 20px; border-bottom:1px solid var(--border); display:flex; gap:12px; align-items:baseline; flex-wrap:wrap}
  h1{margin:0; font-size:20px; letter-spacing:.08em; color:var(--accent)}
  .tag{padding:2px 8px; border:1px solid var(--border); border-radius:999px; color:var(--muted); font-size:12px}
  main{display:grid; grid-template-columns: 420px 1fr 340px; gap:16px; padding:16px}
  @media (max-width: 1200px){ main{grid-template-columns: 1fr} }

  .card{background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:14px;
    box-shadow: 0 10px 20px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.04);}
  .card h2{margin:0 0 10px; font-size:16px; color:var(--accent)}
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  select, button, input{
    background:var(--btn); color:var(--text); border:1px solid var(--border);
    border-radius:10px; padding:8px 10px; font-size:14px;
  }
  input{width:200px}
  button:hover{background:var(--btn-hover)}
  button:disabled{opacity:.45; cursor:not-allowed}
  .accent{background:var(--accent-2); border-color:transparent; color:#04210f; font-weight:700}
  .accent:hover{filter:brightness(1.05)}
  .muted{color:var(--muted); font-size:12px}

  .grid{display:grid; grid-template-columns: repeat(10, minmax(0,1fr)); gap:6px}
  .cell{
    padding:8px 0; text-align:center; border-radius:10px; border:1px solid var(--border);
    user-select:none; cursor:pointer; background:#13301e; transition:transform .05s ease, background .15s ease;
    font-variant-numeric:tabular-nums;
  }
  .cell:hover{transform:translateY(-1px); background:#184029}
  .cell.used{background:var(--grid-used); color:#6e8a78; border-style:dashed; cursor:not-allowed}
  .cell.selected{outline:2px solid var(--accent); box-shadow:0 0 0 2px rgba(53,196,110,.25) inset}

  .log{max-height:320px; overflow:auto; font-family:ui-monospace,Consolas,monospace; font-size:12px; line-height:1.5}
  .log b{color:var(--good)}
  .listbox{max-height:220px; overflow:auto; background:#0f2016; border:1px solid var(--border); border-radius:10px; padding:8px}
  .kbd{padding:2px 6px; border:1px solid var(--border); border-radius:6px; background:#0f2016; font-size:12px}
  .sep{border-top:1px solid var(--border); margin:10px 0; opacity:.5}

  .qbar button{padding:6px 8px; font-size:12px}
  .qbar .chosen{outline:2px solid var(--accent)}
  .qline{display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:6px}
  .hint{font-size:12px; color:var(--muted)}
</style>
</head>
<body>
<header>
  <h1>Hundred / ハンドレッド</h1>
  <span class="tag">緑テーマ</span>
  <span class="tag">同時公開→判定→削除（リーク防止）</span>
  <span class="tag">奇数優先</span>
  <span class="tag">v2.2.0</span>
</header>

<main>
  <!-- 左：設定＆進行 -->
  <section class="card">
    <h2>セットアップ</h2>
    <div class="row" style="margin-bottom:8px">
      <label>難易度</label>
      <select id="difficulty">
        <option value="easy">easy</option>
        <option value="normal" selected>normal</option>
        <option value="hard">hard</option>
      </select>

      <label>ラウンド数</label>
      <select id="rounds">
        <option value="5">5</option>
        <option value="9" selected>9</option>
        <option value="13">13</option>
      </select>
    </div>
    <div class="row" style="margin-bottom:8px">
      <label>先手</label>
      <select id="starter">
        <option value="player">あなた</option>
        <option value="ai">AI</option>
        <option value="random" selected>ランダム（初回のみ／以降交互）</option>
      </select>
      <button id="btnNew" class="accent">新しい対局</button>
    </div>
    <div id="status" class="muted">対局を開始してください。</div>

    <div class="sep"></div>

    <h2>ターン</h2>
    <div class="row" style="margin-bottom:8px">
      <div>現在：<span id="turnNow">-</span> / 合計：<span id="turnMax">-</span>　先手：<span id="turnStarter">-</span>　質問者：<span id="asker">-</span></div>
    </div>
    <div class="row" style="margin-bottom:8px">
      <div>スコア：あなた <span id="sYou">0</span> - <span id="sAI">0</span> AI　（引分 <span id="sD">0</span>）</div>
    </div>
    <div class="row">
      <button id="btnReveal" disabled class="accent">同時公開 → 判定</button>
      <button id="btnCleanup" disabled>ターン確定（削除）</button>
    </div>

    <div class="sep"></div>

    <h2>あなたの質問（あなたが後攻＝質問者のとき）</h2>
    <div class="row qbar">
      <button class="qbtn" data-q="one"   disabled>ワン</button>
      <button class="qbtn" data-q="two"   disabled>ツー</button>
      <button class="qbtn" data-q="three" disabled>スリー</button>
      <button class="qbtn" data-q="four"  disabled>フォー</button>
      <button class="qbtn" data-q="five"  disabled>ファイブ</button>
      <button class="qbtn" data-q="six"   disabled>シックス</button>
      <button class="qbtn" data-q="seven" disabled>セブン</button>
      <button class="qbtn" data-q="eight" disabled>エイト</button>
      <button class="qbtn" data-q="nine"  disabled>ナイン</button>
    </div>
    <div class="qline">
      <label for="fourSet" class="hint">フォー用（1〜100の数字を最大4つ、空白区切り）</label>
      <input id="fourSet" placeholder="例: 17 33 70 98" disabled />
    </div>
    <div class="muted">※ あなたが後攻のときのみ選べます。真偽・数値回答はAIの実際の数字から自動判定（嘘はつけません）。</div>
  </section>

  <!-- 中：盤面 -->
  <section class="card">
    <h2>盤面（未使用の数字）</h2>
    <div id="grid" class="grid"></div>
    <div class="muted" style="margin-top:6px">
      勝敗判定：<b>奇数は偶数に勝つ</b>。同じ偶奇なら<b>大きい方が勝ち</b>。同値は引分。<br/>
      ただし、質問が<b>ワン</b>のターンは、<b>質問者が1桁を出し、相手の下1桁と一致</b>なら<b>質問者の勝利</b>。<br/>
      使った数字は「ターン確定（削除）」で初めて盤面から消えます。
    </div>
  </section>

  <!-- 右：相手情報＆ログ -->
  <section class="card">
    <h2>相手情報</h2>
    <div class="muted">後攻（質問者）はあなたかAI。AIが質問者のときは自動選択・自動評価。</div>
    <div class="sep"></div>
    <div><b>AI未使用（=残り）</b></div>
    <div id="listAI" class="listbox"></div>
    <div style="height:8px"></div>
    <div><b>AIが推定する“あなたの候補”</b>：<span id="oppCount">100</span>件</div>
    <div id="listOpp" class="listbox" style="max-height:140px"></div>

    <div class="sep"></div>
    <h2>ログ</h2>
    <div id="log" class="log"></div>
  </section>
</main>

<script>
/* ========= 質問定義 ========= */
const QDEF = {
  one:   {type:"rule"},                           // ワン：特例ルール
  two:   {type:"yn",   fn:x => Math.floor(x/10)%2===0},           // 10の位が2の倍数
  three: {type:"yn",   fn:x => x%3===0},                          // 3の倍数
  four:  {type:"four"},                             // 4つ集合 ∋ x ?
  five:  {type:"mod5"},                             // x mod 5 ∈ {0..4}
  six:   {type:"yn",   fn:x => x<60},                          // 60未満
  seven: {type:"yn",   fn:x => String(x).includes("7")},        // 7を含む
  eight: {type:"yn",   fn:x => Math.floor(x/10)===8},           // 80-89
  nine:  {type:"yn",   fn:x => x>=90}                           // 90以上
};
const QLABEL = {
  one:"ワン", two:"ツー", three:"スリー", four:"フォー", five:"ファイブ",
  six:"シックス", seven:"セブン", eight:"エイト", nine:"ナイン"
};

/* ========= デコイ集合（指定） ========= */
const STRONG_DECOYS = [90, 80, 70, 96, 84, 78, 72];
const NEXT_DECOYS   = [98, 94, 92, 88, 86, 82, 76, 74];
const ALL_DECOYS = [...STRONG_DECOYS, ...NEXT_DECOYS];

/* ========= 状態 ========= */
const state = {
  difficulty: "normal",
  roundsMax: 9,
  turn: 0,
  turnStarter: "player",
  asker: "ai", // 後攻＝質問者
  available: new Set(),
  oppCandidates: new Set(),
  pendingAI: null,
  pendingPL: null,
  score: {you:0, ai:0, draw:0},
  lastTactic: "normal",
  // 質問
  qBy:null, qKey:null, qEvaluated:false,
  qFourSet:[], // フォー用
};

const $ = sel => document.querySelector(sel);
const gridEl = $("#grid"), logEl = $("#log"), statusEl = $("#status");
const listAI=$("#listAI"), listOpp=$("#listOpp"), oppCount=$("#oppCount");
const sYou=$("#sYou"), sAI=$("#sAI"), sD=$("#sD"), turnNow=$("#turnNow"), turnMax=$("#turnMax"), turnStarter=$("#turnStarter"), askerEl=$("#asker");
const fourInput=$("#fourSet");

/* ========= 便利 ========= */
function log(line){ const div=document.createElement("div"); div.innerHTML=line; logEl.appendChild(div); logEl.scrollTop=logEl.scrollHeight; }
function numArrayDesc(set){ return Array.from(set).sort((a,b)=>b-a); }
function renderLists(){
  listAI.textContent = numArrayDesc(state.available).join(", ");
  const arrOpp = numArrayDesc(state.oppCandidates);
  oppCount.textContent = arrOpp.length;
  listOpp.textContent = arrOpp.slice(0,160).join(", ") + (arrOpp.length>160 ? " ..." : "");
}
function renderGrid(){
  gridEl.innerHTML="";
  for(let n=100;n>=1;--n){
    const cell=document.createElement("div");
    cell.className="cell"; cell.textContent=n;
    if(!state.available.has(n)){
      cell.classList.add("used");
    }else{
      cell.addEventListener("click", ()=>{
        state.pendingPL = (state.pendingPL===n ? null : n);
        Array.from(gridEl.children).forEach(c=>c.classList.remove("selected"));
        if(state.pendingPL===n) cell.classList.add("selected");
        onPlayerPickedMaybeAdvance();
      });
    }
    gridEl.appendChild(cell);
  }
}
function updateScore(){ sYou.textContent=state.score.you; sAI.textContent=state.score.ai; sD.textContent=state.score.draw; }
function setButtons({reveal, cleanup}){ $("#btnReveal").disabled=!reveal; $("#btnCleanup").disabled=!cleanup; }
function setQuestionUIEnabled(enabled){
  document.querySelectorAll(".qbtn").forEach(b=>b.disabled=!enabled);
  fourInput.disabled = !enabled;
  if(!enabled){
    document.querySelectorAll(".qbtn").forEach(b=>b.classList.remove("chosen"));
    fourInput.value=""; state.qFourSet=[];
  }
}
function syncRevealButton(){
  const numbersReady = (state.pendingPL!=null && state.pendingAI!=null);
  const qReady = !!state.qKey; // 後攻側は必ず質問キーが必要
  $("#btnReveal").disabled = !(numbersReady && qReady);
}

/* ========= 初期化 ========= */
function resetGame(){
  state.available = new Set(Array.from({length:100},(_,i)=>i+1));
  state.oppCandidates = new Set(Array.from({length:100},(_,i)=>i+1));
  state.pendingAI=null; state.pendingPL=null;
  state.score={you:0, ai:0, draw:0}; state.lastTactic="normal";
  state.turn=0; state.qBy=null; state.qKey=null; state.qEvaluated=false; state.qFourSet=[];
  state.roundsMax = parseInt($("#rounds").value,10);
  const starterSel = $("#starter").value;
  state.turnStarter = (starterSel==="random") ? (Math.random()<0.5?"player":"ai") : starterSel;
  state.asker = (state.turnStarter==="player") ? "ai" : "player";
  $("#turnMax").textContent = state.roundsMax.toString();
  $("#turnNow").textContent = "0";
  $("#turnStarter").textContent = (state.turnStarter==="player") ? "あなた" : "AI";
  $("#asker").textContent = (state.asker==="player") ? "あなた" : "AI";
  state.difficulty = $("#difficulty").value;

  logEl.innerHTML="";
  statusEl.textContent = "対局開始。後攻が質問者。奇数優先、同偶奇は大きい方。";
  renderGrid(); renderLists(); updateScore();
  setButtons({reveal:false, cleanup:false});
  setQuestionUIEnabled(state.asker==="player");

  nextTurn();
}

/* ========= 難易度別AI選択（奇数優先＋定石） ========= */
function tacticSleepless(avail){
  const arr=[...avail];
  const prio = arr.filter(x=> x%2===1 && x%3===0 && x>=69);
  if(prio.length) return Math.max(...prio);
  const odd = arr.filter(x=> x%2===1);
  if(odd.length) return Math.max(...odd);
  // 奇数枯渇 → 最小偶数で被害最小
  const ev = arr.filter(x=>x%2===0).sort((a,b)=>a-b);
  return ev.length? ev[0] : Math.max(...arr);
}
function tactic90Decoy(avail){
  for(const k of ALL_DECOYS){ if(avail.has(k)) return k; }
  const arr = [...avail].sort((a,b)=>a-b);
  for(const x of arr){ if(x%2===0) return x; } // 偶数は基本負け→捨て石
  for(const x of arr){ if(x%2===1) return x; }
  return arr[0];
}
function tacticNormal(avail){
  const arr=[...avail];
  const odd = arr.filter(x=>x%2===1);
  if(odd.length>=10){
    const o80 = odd.filter(x=>x>=80); if(o80.length) return Math.max(...o80);
    const o70 = odd.filter(x=>x>=70); if(o70.length) return Math.max(...o70);
  }
  if(odd.length) return Math.max(...odd);
  const ev = arr.filter(x=>x%2===0).sort((a,b)=>a-b);
  return ev.length? ev[0] : Math.max(...arr);
}
function aiPickNumber(){
  const diff = $("#difficulty").value;
  let useSleepless=false, useDecoy=false;
  if(diff==="hard"){
    const r=Math.random();
    if(r<0.5) useSleepless=true; else if(r<0.9) useDecoy=true;
  }else{
    const base=(diff==="normal")?0.12:0.07;
    const canStrong = (state.lastTactic!=="sleepless" && state.lastTactic!=="decoy");
    if(canStrong && Math.random()<base){ if(Math.random()<0.5) useSleepless=true; else useDecoy=true; }
  }
  let choice;
  if(useSleepless){ choice=tacticSleepless(state.available); state.lastTactic="sleepless"; }
  else if(useDecoy){ choice=tactic90Decoy(state.available); state.lastTactic="decoy"; }
  else { choice=tacticNormal(state.available); state.lastTactic="normal"; }
  return choice;
}

/* ========= 質問選択（UI） ========= */
document.querySelectorAll(".qbtn").forEach(btn=>{
  btn.addEventListener("click", ()=>{
    if(state.asker!=="player") return;
    document.querySelectorAll(".qbtn").forEach(b=>b.classList.remove("chosen"));
    btn.classList.add("chosen");
    state.qKey = btn.dataset.q;
    state.qBy = "player";
    state.qEvaluated = false;
    // フォーのときは入力を活性化
    fourInput.disabled = (state.qKey!=="four");
    if(state.qKey!=="four"){ state.qFourSet=[]; fourInput.value=""; }
    log(`<b>あなたの質問</b>: ${QLABEL[state.qKey]}`);
    syncRevealButton();
  });
});
fourInput.addEventListener("change", ()=>{
  const vals = fourInput.value.trim().split(/\s+/).filter(s=>s.length>0).map(s=>parseInt(s,10)).filter(n=>Number.isInteger(n)&&n>=1&&n<=100);
  state.qFourSet = [...new Set(vals)].slice(0,4);
  fourInput.value = state.qFourSet.join(" ");
  log(`<span class="hint">フォー集合: [${state.qFourSet.join(", ")}]</span>`);
  syncRevealButton();
});

/* ========= AIが質問者のときの自動選択 ========= */
function aiChooseQuestion(){
  // 簡易ヒューリスティック：候補の分割が効く順に優先。たまに“五”や“四”を混ぜる。
  const cand = [];
  const tryKey = (k)=>{ cand.push(k); };
  const rnd=Math.random();
  if(rnd<0.15) tryKey("five");
  else if(rnd<0.3) tryKey("four");
  tryKey("two"); tryKey("three"); tryKey("six"); tryKey("seven"); tryKey("eight"); tryKey("nine"); tryKey("one");

  for(const k of cand){
    if(k==="four"){
      // oppCandidates の四分位近辺を4点選ぶ
      const arr = numArrayDesc(state.oppCandidates).sort((a,b)=>a-b);
      const picks=[]; const pts=[0.2,0.4,0.6,0.8];
      for(const p of pts){ const idx=Math.min(arr.length-1, Math.max(0, Math.floor(arr.length*p))); picks.push(arr[idx]); }
      state.qFourSet = [...new Set(picks)].slice(0,4);
      if(state.qFourSet.length<1) continue;
      state.qKey="four"; state.qBy="ai"; state.qEvaluated=false;
      log(`<b>AIの質問</b>: フォー（候補: ${state.qFourSet.join(", ")})`);
      return;
    }else{
      state.qKey=k; state.qBy="ai"; state.qEvaluated=false;
      log(`<b>AIの質問</b>: ${QLABEL[k]}`);
      return;
    }
  }
}

/* ========= ターン制御 ========= */
function nextTurn(){
  if(state.turn>=state.roundsMax){ endGame(); return; }
  state.turn += 1;
  $("#turnNow").textContent = String(state.turn);

  // 交互に先手・後攻を切替
  if(state.turn===1){
    const starterSel=$("#starter").value;
    state.turnStarter = (starterSel==="random") ? (Math.random()<0.5?"player":"ai") : starterSel;
  }else{
    state.turnStarter = (state.turnStarter==="player") ? "ai" : "player";
  }
  state.asker = (state.turnStarter==="player") ? "ai" : "player";
  $("#turnStarter").textContent = (state.turnStarter==="player") ? "あなた" : "AI";
  $("#asker").textContent = (state.asker==="player") ? "あなた" : "AI";

  // ターン初期化
  state.pendingAI=null; state.pendingPL=null;
  state.qBy=null; state.qKey=null; state.qEvaluated=false; state.qFourSet=[];
  setQuestionUIEnabled(state.asker==="player");
  setButtons({reveal:false, cleanup:false});
  Array.from(gridEl.children).forEach(c=>c.classList.remove("selected"));

  if(state.turnStarter==="player"){
    statusEl.textContent = "あなたが先手。AIが後攻＝質問者なので、あなたが選ぶとAIが質問を自動で決めます。";
  }else{
    statusEl.textContent = "AIが先手（あなたが後攻＝質問者）。まずAIが黙って数字を決めます。あなたは質問を選んでから数字を選んでOK。";
    state.pendingAI = aiPickNumber();
  }

  renderGrid(); renderLists();
}

/* あなたが数字を選んだら進行 */
function onPlayerPickedMaybeAdvance(){
  if(state.pendingPL==null){ syncRevealButton(); return; }

  if(state.turnStarter==="player"){
    // 先手はあなた → AIが質問者。あなたが選んだらAIが質問を選ぶ。
    if(!state.qKey){ aiChooseQuestion(); }
    // AIも黙って数字を決める
    if(state.pendingAI==null) state.pendingAI = aiPickNumber();
  }else{
    // 先手はAI → あなたが質問者。質問を選んでいないなら公開できない。
  }
  syncRevealButton();
}

/* ========= 公開→評価→判定→削除 ========= */
function evaluateQuestionAutomatically(){
  if(!state.qKey) return;
  const def = QDEF[state.qKey];
  if(def.type==="rule"){
    // ワン：数値判定はなし。判定時に特例を適用。
    log(`→ ルール変更（ワン）適用：質問者が1桁かつ下1桁一致なら質問者勝利`);
    state.qEvaluated=true; return;
  }
  if(def.type==="yn"){
    // Yes/No：評価対象は「質問者が相手の数字で判定」
    const target = (state.qBy==="ai") ? state.pendingPL : state.pendingAI;
    const truth = !!def.fn(target);
    if(state.qBy==="ai"){
      // AIはあなた候補を更新
      const before = state.oppCandidates.size;
      const next=new Set();
      for(const x of state.oppCandidates){ if(!!def.fn(x)===truth) next.add(x); }
      state.oppCandidates=next; renderLists();
      log(`→ <b>${truth?'Yes':'No'}</b>（自動） candidates ${before}→${state.oppCandidates.size}`);
    }else{
      log(`→ <b>${truth?'Yes':'No'}</b>（自動・AIの数字）`);
    }
    state.qEvaluated=true; return;
  }
  if(def.type==="four"){
    const set=new Set(state.qFourSet);
    const target = (state.qBy==="ai") ? state.pendingPL : state.pendingAI;
    const truth = set.has(target);
    if(state.qBy==="ai"){
      const before = state.oppCandidates.size;
      const next=new Set();
      for(const x of state.oppCandidates){ if(set.has(x)===truth) next.add(x); }
      state.oppCandidates=next; renderLists();
      log(`→ <b>${truth?'Yes':'No'}</b>（フォー: [${state.qFourSet.join(", ")}]） candidates ${before}→${state.oppCandidates.size}`);
    }else{
      log(`→ <b>${truth?'Yes':'No'}</b>（フォー: [${state.qFourSet.join(", ")}], AIの数字）`);
    }
    state.qEvaluated=true; return;
  }
  if(def.type==="mod5"){
    const target = (state.qBy==="ai") ? state.pendingPL : state.pendingAI;
    const r = (target%5+5)%5;
    if(state.qBy==="ai"){
      // 形式上は数値回答。候補絞りは r と一致する要素のみ。
      const before = state.oppCandidates.size;
      const next=new Set();
      for(const x of state.oppCandidates){ if(((x%5+5)%5)===r) next.add(x); }
      state.oppCandidates=next; renderLists();
      log(`→ <b>余り ${r}</b>（自動） candidates ${before}→${state.oppCandidates.size}`);
    }else{
      log(`→ <b>余り ${r}</b>（自動・AIの数字）`);
    }
    state.qEvaluated=true; return;
  }
}

function revealAndJudge(){
  if(state.pendingPL==null || state.pendingAI==null){ alert("両者の数字が未確定です。"); return; }
  if(!state.qKey){ alert("質問を選んでください。（質問者は後攻です）"); return; }

  // 未評価ならここで自動評価
  if(!state.qEvaluated) evaluateQuestionAutomatically();

  const ai = state.pendingAI, pl = state.pendingPL;
  let res="Draw";

  // まずワン特例（ルール変更）を適用
  if(state.qKey==="one"){
    const askerIsPlayer = (state.asker==="player");
    const askerNum = askerIsPlayer ? pl : ai;
    const otherNum = askerIsPlayer ? ai : pl;
    if(askerNum>=1 && askerNum<=9 && (askerNum%10)===(otherNum%10)){
      res = askerIsPlayer ? "Player" : "AI";
    }else{
      // 特例が適用されない場合は通常判定へフォールバック
      res = judgeByOddPriority(pl, ai);
    }
  }else{
    res = judgeByOddPriority(pl, ai);
  }

  if(res==="Player") state.score.you++;
  else if(res==="AI") state.score.ai++;
  else state.score.draw++;

  log(`<b>[公開]</b> AI=${ai} / You=${pl} → <b>${res}</b>`);
  statusEl.textContent = "判定完了。続いて「ターン確定（削除）」で盤面を更新します。";
  updateScore();
  setButtons({reveal:false, cleanup:true});
}
function judgeByOddPriority(pl, ai){
  const aiOdd=(ai%2===1), plOdd=(pl%2===1);
  if(aiOdd!==plOdd){ return plOdd ? "Player" : "AI"; }
  if(pl>ai) return "Player";
  if(pl<ai) return "AI";
  return "Draw";
}

function cleanup(){
  // このタイミングで初めて available を縮める（リーク防止）
  for(const u of [state.pendingAI, state.pendingPL]){ if(state.available.has(u)) state.available.delete(u); }
  state.pendingAI=null; state.pendingPL=null;
  state.qBy=null; state.qKey=null; state.qEvaluated=false; state.qFourSet=[];
  renderGrid(); renderLists();
  setButtons({reveal:false, cleanup:false});

  if(state.turn>=state.roundsMax){ endGame(); }
  else { nextTurn(); }
}

function endGame(){
  const msg = `最終スコア：あなた ${state.score.you} - ${state.score.ai} AI（引分 ${state.score.draw}）`;
  log(`<b>=== 終局 ===</b> ${msg}`);
  statusEl.textContent = msg + "　新しい対局で再開できます。";
  $("#btnReveal").disabled = true; $("#btnCleanup").disabled = true;
}

/* ========= イベント ========= */
$("#btnReveal").addEventListener("click", ()=>{ revealAndJudge(); });
$("#btnCleanup").addEventListener("click", ()=>{ cleanup(); });
$("#btnNew").addEventListener("click", ()=>{ resetGame(); });

/* 初期起動 */
resetGame();
</script>
</body>
</html>
