<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ハンドレッド / Hundred ver 3.1.3-fix</title>
<style>
  :root{
    --bg:#0e1a12; --bg2:#122216; --panel:#152a1b; --accent:#35c46e; --accent-2:#2aa55b;
    --text:#e7ffe7; --muted:#b9d8c0; --warn:#ffd37a; --bad:#ff8a8a; --good:#8affb9;
    --grid-used:#2a3a2f; --btn:#173d26; --btn-hover:#1f5333; --border:#2f6848;
  }
  *{box-sizing:border-box}
  body{margin:0; background:linear-gradient(180deg,var(--bg),var(--bg2)); color:var(--text);
    font-family:ui-sans-serif,system-ui,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif;}
  header{padding:18px 20px; border-bottom:1px solid var(--border); display:flex; gap:12px; align-items:baseline; flex-wrap:wrap}
  h1{margin:0; font-size:20px; letter-spacing:.08em; color:var(--accent)}
  main{display:grid; grid-template-columns: 420px 1fr 340px; gap:16px; padding:16px}
  @media (max-width: 1200px){ main{grid-template-columns: 1fr} }

  .card{background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:14px;
    box-shadow: 0 10px 20px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.04);}
  .card h2{margin:0 0 10px; font-size:16px; color:var(--accent)}
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  select, button, input{
    background:var(--btn); color:var(--text); border:1px solid var(--border);
    border-radius:10px; padding:8px 10px; font-size:14px;
  }
  input{width:220px}
  button:hover{background:var(--btn-hover)}
  button:disabled{opacity:.45; cursor:not-allowed}
  .accent{background:var(--accent-2); border-color:transparent; color:#04210f; font-weight:700}
  .accent:hover{filter:brightness(1.05)}
  .muted{color:var(--muted); font-size:12px}

  .grid{display:grid; grid-template-columns: repeat(10, minmax(0,1fr)); gap:6px}
  .cell{
    padding:8px 0; text-align:center; border-radius:10px; border:1px solid var(--border);
    user-select:none; cursor:pointer; background:#13301e; transition:transform .05s ease, background .15s ease;
    font-variant-numeric:tabular-nums;
  }
  .cell:hover{transform:translateY(-1px); background:#184029}
  .cell.used{background:var(--grid-used); color:#6e8a78; border-style:dashed; cursor:not-allowed}
  .cell.selected{outline:2px solid var(--accent); box-shadow:0 0 0 2px rgba(53,196,110,.25) inset}
  .disabled{pointer-events:none; opacity:.6}

  .log{max-height:420px; overflow:auto; font-family:ui-monospace,Consolas,monospace; font-size:12px; line-height:1.5}
  .log b{color:var(--good)}
  .listbox{max-height:220px; overflow:auto; background:#0f2016; border:1px solid var(--border); border-radius:10px; padding:8px}
  .kbd{padding:2px 6px; border:1px solid var(--border); border-radius:6px; background:#0f2016; font-size:12px}
  .sep{border-top:1px solid var(--border); margin:10px 0; opacity:.5}

  .qbar button{padding:6px 8px; font-size:12px}
  .qbar .chosen{outline:2px solid var(--accent)}
  .qline{display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:6px}
  .hint{font-size:12px; color:#cfe9d5}

  .rules-raw{white-space:pre-wrap; font-family:ui-monospace,Consolas,monospace; font-size:13px; line-height:1.7; background:#0f2016; border:1px solid var(--border); border-radius:12px; padding:12px; color:var(--text); max-height:520px; overflow:auto}
</style>
</head>
<body>
<header>
  <h1>ハンドレッド / Hundred ver 3.1.3-fix</h1>
</header>

<main>
  <!-- 左：設定＆進行 -->
  <section class="card">
    <h2>セットアップ</h2>
    <div class="row" style="margin-bottom:8px">
      <label>難易度</label>
      <select id="difficulty">
        <option value="easy">easy</option>
        <option value="normal" selected>normal</option>
        <option value="hard">hard</option>
        <option value="expert">expert</option>
        <option value="hell">hell</option>
      </select>

      <label>先取本数</label>
      <select id="targetWins">
        <option value="5" selected>5</option>
        <option value="9">9</option>
        <option value="13">13</option>
      </select>
    </div>
    <div class="row" style="margin-bottom:8px">
      <label>先手</label>
      <select id="starter">
        <option value="player">あなた</option>
        <option value="ai">AI</option>
        <option value="random" selected>ランダム（初回のみ／以降交互）</option>
      </select>
      <button id="btnNew" class="accent">新しい対局</button>
    </div>
    <div id="status" class="muted">対局を開始してください。</div>

    <div class="sep"></div>

    <h2>ターン</h2>
    <div class="row" style="margin-bottom:8px">
      <div>ターン：<span id="turnNow">-</span>　先手：<span id="turnStarter">-</span>　質問者：<span id="asker">-</span></div>
    </div>
    <div class="row" style="margin-bottom:8px">
      <div>スコア（先取 <span id="winTargetLabel">5</span>）：あなた <span id="sYou">0</span> - <span id="sAI">0</span> AI　（引分 <span id="sD">0</span>）</div>
    </div>
    <div class="row">
      <button id="btnReveal" disabled class="accent">同時公開 → 判定</button>
      <button id="btnCleanup" disabled>（自動削除中）</button>
    </div>

    <div class="sep"></div>

    <h2>あなたの質問（あなたが後攻＝質問者のとき）</h2>
    <div class="row qbar">
      <button class="qbtn" data-q="one"   disabled>ワン</button>
      <button class="qbtn" data-q="two"   disabled>ツー</button>
      <button class="qbtn" data-q="three" disabled>スリー</button>
      <button class="qbtn" data-q="four"  disabled>フォー</button>
      <button class="qbtn" data-q="five"  disabled>ファイブ</button>
      <button class="qbtn" data-q="six"   disabled>シックス</button>
      <button class="qbtn" data-q="seven" disabled>セブン</button>
      <button class="qbtn" data-q="eight" disabled>エイト</button>
      <button class="qbtn" data-q="nine"  disabled>ナイン</button>
    </div>
    <div class="qline">
      <label for="setInput" class="hint">シックス用（1〜100の数字を<b>最大6つ</b>、空白区切り）</label>
      <input id="setInput" placeholder="例: 17 33 70 98 41 12" disabled />
    </div>
    <div class="muted">※ 後攻（質問者）のときだけ選べます。選んだら<b>即回答</b>がログ表示。このターンは<b>1回のみ</b>選択可能。<br>
    <span class="hint">シックスは<b>数字を入力してから</b>評価されます。フォーは mod4 の余り回答。</span></div>
  </section>

  <!-- 中：盤面（あなたの未使用数字だけ） -->
  <section class="card">
    <h2>盤面（あなたの未使用の数字）</h2>
    <div id="grid" class="grid"></div>
  </section>

  <!-- 右：相手情報＆ログ -->
  <section class="card">
    <h2>相手情報</h2>
    <div class="muted">右の一覧は<b>AIの未使用数字</b>。AIが質問者のときは自動選択・即時自動回答。</div>
    <div class="sep"></div>
    <div><b>AI未使用（=残り）</b></div>
    <div id="listAI" class="listbox"></div>
    <div class="sep"></div>
    <h2>ログ</h2>
    <div id="log" class="log"></div>
  </section>
</main>

<section class="card" style="margin:0 16px 16px">
  <h2>ルール</h2>
  <pre class="rules-raw">【基本ルール】

あなたとAIは、それぞれ1～100の数字カードを持っています。
先攻後攻ともに、数字カードを１つ出します。
数字がでかい方の勝ちです。
同じだったら引き分けになります。
１度使ったカードはもう使えません。

これを先攻後攻を交代しながら、先に決まった回数勝利すれば勝ちです。
ただしリードが１差のままでは決着せず、
両者が先取本数に到達（例：5-5）するとデュース（Win by 2）になります。

【応用ルール】
(1)すべての偶数は、すべての奇数に負けます。あらゆるルールに優先します。
(2)お互い３の倍数だった場合にかぎり、「より小さい方」が勝ちます。
　このルールは(1)より弱いです。
　９９と３なら３の勝ちですが、９９と６は９９の勝ちです。奇数なので。
(3)後述する「ワン」を利用した場合、成功すれば「ワン」が勝ちます。

【9つの権利（後攻専用、ver3.1.3）】
ワン    このターン限定の特例：質問者が1〜9を出し、相手の下1桁と一致したら質問者の即勝利
ツー    質問者の自分の数に +2（100を超えてもよい）
スリー  相手が３の倍数か聞ける（Yes/No）
フォー  相手の数を4で割った余り（0〜3）を聞ける
ファイブ 相手の数を5で割った余り（0〜4）を聞ける
シックス あなたが最大6つの数字を指定し、そのいずれかかどうかを聞ける（Yes/No）
セブン  あなたの数字の「10 の位」を 7 にする（例: 53→73）。変換元・変換先は自分側で未使用であること。使用後、消費されるのは変換元のみ。<b>失敗時はやり直し（質問も数字も再選択可）</b>。
エイト  相手が80以上かどうかを聞ける（Yes/No）
ナイン  質問者の自分の数を9倍にする（上限なし）
</pre>
</section>

<script>
/* ========= 質問定義（ver3.1.3） ========= */
const QDEF = {
  one:   {type:"rule"},
  two:   {type:"self", op:"plus2"},             // 自分の数を+2
  three: {type:"yn",   fn:x => x%3===0},        // 3の倍数か
  four:  {type:"mod4"},                         // 4の余り
  five:  {type:"mod5"},                         // 5の余り
  six:   {type:"setN", n:6},                    // 6つ候補Yes/No
  seven: {type:"self", op:"to70s"},             // 自分の数の10の位を7にする（fromのみ消費、失敗はやり直し）
  eight: {type:"yn",   fn:x => x>=80},          // 80以上
  nine:  {type:"self", op:"times9"}             // 自分の数を9倍
};
const QLABEL = {
  one:"ワン", two:"ツー", three:"スリー", four:"フォー", five:"ファイブ",
  six:"シックス", seven:"セブン", eight:"エイト", nine:"ナイン"
};

/* ========= デコイ集合 ========= */
const STRONG_DECOYS = [90, 80, 70, 96, 84, 78, 72];
const NEXT_DECOYS   = [98, 94, 92, 88, 86, 82, 76, 74];
const ALL_DECOYS = [...STRONG_DECOYS, ...NEXT_DECOYS];

/* ========= 状態 ========= */
const state = {
  difficulty: "normal",
  turn: 0,
  turnStarter: "player",
  asker: "ai",

  winTarget: 5,
  deuce: false,

  availablePL: new Set(),
  availableAI: new Set(),

  oppCandidates: new Set(),
  pendingAI: null,
  pendingPL: null,
  baseAI: null,           // 元の選択（自己操作で値が変わっても、消費するのはこの元カード）
  basePL: null,
  score: {you:0, ai:0, draw:0},
  lastTactic: "normal",

  qKey:null, qLocked:false, qEvaluated:false,
  qSetN:[],                // シックス用の集合（最大6）
  qAsker:null,

  revealed:false,
  history: {player:[], ai:[]}
};

const $ = sel => document.querySelector(sel);
const gridEl = $("#grid"), logEl = $("#log"), statusEl = $("#status");
const listAI=$("#listAI");
const setInput=$("#setInput");

/* ========= 便利 ========= */
function log(line){ const div=document.createElement("div"); div.innerHTML=line; logEl.appendChild(div); logEl.scrollTop=logEl.scrollHeight; }
function numArrayDesc(set){ return Array.from(set).sort((a,b)=>b-a); }
function renderLists(){ if(listAI) listAI.textContent = numArrayDesc(state.availableAI).join(", "); }
function renderGrid(){
  gridEl.innerHTML="";
  for(let n=100;n>=1;--n){
    const cell=document.createElement("div");
    cell.className="cell"; cell.textContent=n;
    if(!state.availablePL.has(n)){
      cell.classList.add("used");
    }else{
      cell.addEventListener("click", ()=>{
        if(state.revealed) return;
        state.pendingPL = (state.pendingPL===n ? null : n);
        state.basePL = state.pendingPL; // 元カードを常に最新の選択へ同期
        Array.from(gridEl.children).forEach(c=>c.classList.remove("selected"));
        if(state.pendingPL===n) cell.classList.add("selected");
        onPlayerPickedMaybeAdvance();
      });
    }
    gridEl.appendChild(cell);
  }
}
function updateScore(){ $("#sYou").textContent=state.score.you; $("#sAI").textContent=state.score.ai; $("#sD").textContent=state.score.draw; }
function setButtons({reveal, cleanup}){ $("#btnReveal").disabled=!reveal; $("#btnCleanup").disabled=!cleanup; }
function setQuestionUIEnabled(enabled){
  document.querySelectorAll(".qbtn").forEach(b=>b.disabled=!enabled || state.qLocked);
  setInput.disabled = !enabled || state.qLocked || state.qKey!=="six";
}
function clearQChosen(){ document.querySelectorAll(".qbtn").forEach(b=>b.classList.remove("chosen")); }
function syncRevealButton(){
  // 保険：AIが質問者で qKey 未確定なら自動確定
  if(state.asker === "ai" && !state.qKey && !state.revealed){
    state.qAsker = "ai";
    aiChooseQuestion();
  }
  const numbersReady = (state.pendingPL!=null && state.pendingAI!=null);
  let qReady = !!state.qKey;
  if(state.asker==="ai" && !state.qKey) qReady = false; // AIも原則、権利が確定してから公開
  if(state.qKey==="six") qReady = qReady && state.qEvaluated;
  $("#btnReveal").disabled = !(numbersReady && qReady) || state.revealed;
}

/* ========= 初期化 ========= */
function resetGame(){
  state.availablePL = new Set(Array.from({length:100},(_,i)=>i+1));
  state.availableAI = new Set(Array.from({length:100},(_,i)=>i+1));
  state.oppCandidates = new Set(Array.from({length:100},(_,i)=>i+1));
  state.pendingAI=null; state.pendingPL=null; state.baseAI=null; state.basePL=null;
  state.score={you:0, ai:0, draw:0}; state.lastTactic="normal";
  state.turn=0; state.qKey=null; state.qLocked=false; state.qEvaluated=false; state.qSetN=[];
  state.qAsker=null; state.revealed=false; state.deuce=false; state.history={player:[], ai:[]};

  state.winTarget = parseInt($("#targetWins").value,10);
  $("#winTargetLabel").textContent = String(state.winTarget);

  const starterSel = $("#starter").value;
  state.turnStarter = (starterSel==="random") ? (Math.random()<0.5?"player":"ai") : starterSel;
  state.asker = (state.turnStarter==="player") ? "ai" : "player";
  state.qAsker = null;

  $("#turnNow").textContent = "0";
  logEl.innerHTML="";
  statusEl.textContent = "対局開始。先取本数方式。両者が先取に到達するとデュース（Win by 2）。";
  renderGrid(); renderLists(); updateScore();
  setButtons({reveal:false, cleanup:false});
  setQuestionUIEnabled(state.asker==="player");
  nextTurn();
}

/* ========= スリープレス圧など（ver2のまま） ========= */
function isSleeplessPressure(){
  const p = state.history.player;
  if(p.length===0) return false;
  const last = p[p.length-1];
  if(last%2===1 && last>=85) return true;
  if(last>=69 && (last%3===0 || (last-1)%3===0 || (last+1)%3===0)) return true;
  return false;
}
function pickEvenEscape(avail){
  const wishlist = [96, 84, 78, 72, 66, 60, 90, 48, 36, 30];
  for(const k of wishlist){ if(avail.has(k)) return k; }
  const arr=[...avail].sort((a,b)=>a-b);
  for(const x of arr){ if(x%2===0 && x%3===0) return x; }
  for(const x of arr){ if(x%2===0) return x; }
  return arr[0];
}

/* ========= AIの戦術（ver2のまま） ========= */
function tacticSleepless(avail){
  const arr=[...avail];
  const prio = arr.filter(x=> x%2===1 && x%3===0 && x>=69);
  if(prio.length) return Math.max(...prio);
  const odd = arr.filter(x=> x%2===1);
  if(odd.length) return Math.max(...odd);
  const ev = arr.filter(x=>x%2===0).sort((a,b)=>a-b);
  return ev.length? ev[0] : Math.max(...arr);
}
function tactic90Decoy(avail){
  for(const k of ALL_DECOYS){ if(avail.has(k)) return k; }
  const arr = [...avail].sort((a,b)=>a-b);
  for(const x of arr){ if(x%2===0) return x; }
  for(const x of arr){ if(x%2===1) return x; }
  return arr[0];
}
function tacticOddThreat(avail){
  const odd = [...avail].filter(x=>x%2===1).sort((a,b)=>b-a);
  if(odd.length===0) return Math.max(...avail);
  const non3 = odd.filter(x=>x%3!==0);
  return (non3.length? non3[0] : odd[0]);
}
function tacticNormal(avail){
  const arr=[...avail];
  const odd = arr.filter(x=>x%2===1);
  if(odd.length>=10){
    const o80 = odd.filter(x=>x>=80); if(o80.length) return Math.max(...o80);
    const o70 = odd.filter(x=>x>=70); if(o70.length) return Math.max(...o70);
  }
  if(odd.length) return Math.max(...odd);
  const ev = arr.filter(x=>x%2===0).sort((a,b)=>a-b);
  return ev.length? ev[0] : Math.max(...arr);
}

/* ========= 勝率＆情報利得ユーティリティ ========= */
function judgeCore(pl, ai){
  const aiOdd=(ai%2===1), plOdd=(pl%2===1);
  if(aiOdd!==plOdd){ return plOdd ? "Player" : "AI"; }
  const aiM3=(ai%3===0), plM3=(pl%3===0);
  if(aiM3 && plM3){
    if(pl<ai) return "Player";
    if(pl>ai) return "AI";
    return "Draw";
  }
  if(pl>ai) return "Player";
  if(pl<ai) return "AI";
  return "Draw";
}
function estimateWinRate(myPick, oppSet){
  let w=0, d=0, l=0;
  for(const opp of oppSet){
    const r = judgeCore(opp, myPick);
    if(r==="AI") w++; else if(r==="Draw") d++; else l++;
  }
  const n = Math.max(1, w+d+l);
  return (w + 0.5*d) / n;
}
function pickByWinrate(avail, {aiIsStarter, remain}){
  const opp = (state.oppCandidates.size? state.oppCandidates :
               new Set(Array.from({length:100},(_,i)=>i+1)));
  let cand = [...avail];
  if(!aiIsStarter && remain>30){
    const odd = cand.filter(x=>x%2===1);
    if(odd.length) cand = odd;
  }
  let best=cand[0], bestS=-1;
  for(const x of cand){
    const s = estimateWinRate(x, opp);
    const score = s
      + (aiIsStarter && ALL_DECOYS.includes(x) ? 0.02 : 0)
      + (x%2===1 ? 0.005 : 0);
    if(score>bestS){ bestS=score; best=x; }
  }
  const ties = cand.filter(x=>{
    const s = estimateWinRate(x, opp)
      + (aiIsStarter && ALL_DECOYS.includes(x) ? 0.02 : 0)
      + (x%2===1 ? 0.005 : 0);
    return Math.abs(s-bestS) < 1e-3;
  });
  if(ties.length>1) best = ties[Math.floor(Math.random()*ties.length)];
  return best;
}

/* ========= 汎用集合生成（k点） ========= */
function buildSetFromCandidates(candSet, k){
  const arr = Array.from(candSet).sort((a,b)=>a-b);
  if(arr.length===0) return [];
  const picks = [];
  for(let i=1;i<=k;i++){
    const p = i/(k+1);
    const idx = Math.max(0, Math.min(arr.length-1, Math.floor(arr.length*p)));
    picks.push(arr[idx]);
  }
  return [...new Set(picks.filter(Number.isInteger))].slice(0,k);
}

/* ========= AIの出目ロジック ========= */
function aiPickNumber(){
  const diff = $("#difficulty").value;

  if(diff==="hell"){
    const aiIsStarter = (state.turnStarter==="ai");
    const pick = pickByWinrate(state.availableAI, {aiIsStarter, remain: state.availableAI.size});
    state.baseAI = pick; return pick;
  }

  if(diff==="expert"){
    const aiIsStarter = (state.turnStarter==="ai");
    let pick;
    if(aiIsStarter){
      if(Math.random()<0.75){ state.lastTactic="decoy"; pick = tactic90Decoy(state.availableAI); }
      else { state.lastTactic="odd-threat"; pick = tacticOddThreat(state.availableAI); }
    }else{
      const remain = state.availableAI.size;
      const oddExist = [...state.availableAI].some(x=>x%2===1);
      if(remain>30 && oddExist){ state.lastTactic="odd-threat"; pick = tacticOddThreat(state.availableAI); }
      else {
        const r=Math.random();
        if(oddExist && r<0.7){ state.lastTactic="odd-threat"; pick = tacticOddThreat(state.availableAI); }
        else if(r<0.85){ state.lastTactic="decoy"; pick = tactic90Decoy(state.availableAI); }
        else { state.lastTactic="sleepless-hint"; pick = tacticNormal(state.availableAI); }
      }
    }
    state.baseAI = pick; return pick;
  }

  if(diff==="hard" && isSleeplessPressure()){
    const choice = pickEvenEscape(state.availableAI);
    state.lastTactic = "even-escape"; state.baseAI = choice; return choice;
  }

  let useSleepless=false, useDecoy=false;
  if(diff==="hard"){
    const r=Math.random();
    if(r<0.5) useSleepless=true; else if(r<0.9) useDecoy=true;
  }else{
    const base=(diff==="normal")?0.12:0.07;
    const canStrong = (state.lastTactic!=="sleepless" && state.lastTactic!=="decoy");
    if(canStrong && Math.random()<base){ if(Math.random()<0.5) useSleepless=true; else useDecoy=true; }
  }
  let choice;
  if(useSleepless){ choice=tacticSleepless(state.availableAI); state.lastTactic="sleepless"; }
  else if(useDecoy){ choice=tactic90Decoy(state.availableAI); state.lastTactic="decoy"; }
  else { choice=tacticNormal(state.availableAI); state.lastTactic="normal"; }
  state.baseAI = choice; return choice;
}

/* ========= 即時回答・効果適用 ========= */
function evaluateQuestionImmediately(){
  if(!state.qKey || state.qEvaluated) return;
  const asker = state.qAsker; if(!asker) return;

  const def = QDEF[state.qKey];
  const target = (asker==="ai") ? state.pendingPL : state.pendingAI; // 相手の数字（質問対象）
  const selfNum = (asker==="ai") ? state.pendingAI : state.pendingPL; // 自分の数字（自己操作用）

  if(def.type==="rule"){
    log(`→ ルール変更（ワン）は公開時に適用可否を判定`);
    state.qEvaluated = true; return;
  }

  if(def.type==="self"){
    if(selfNum==null){ return; }
    if(def.op==="plus2"){
      if(asker==="ai"){ state.pendingAI = selfNum + 2; log(`<b>AIの権利: ツー</b> → 自分の数 +2 = <b>${state.pendingAI}</b>`); }
      else { state.pendingPL = selfNum + 2; log(`<b>あなたの権利: ツー</b> → 自分の数 +2 = <b>${state.pendingPL}</b>`); }
    }else if(def.op==="times9"){
      if(asker==="ai"){ state.pendingAI = selfNum * 9; log(`<b>AIの権利: ナイン</b> → 自分の数 ×9 = <b>${state.pendingAI}</b>`); }
      else { state.pendingPL = selfNum * 9; log(`<b>あなたの権利: ナイン</b> → 自分の数 ×9 = <b>${state.pendingPL}</b>`); }
    }else if(def.op==="to70s"){
      const to = 70 + (selfNum % 10);
      const avail = (asker==="ai") ? state.availableAI : state.availablePL;
      if(!avail.has(selfNum)){
        log(`<b>${asker==="ai"?"AI":"あなた"}の権利: セブン</b> → <b>セブン失敗</b>（変換元が使用済み）<span class="hint"> 質問と数字を選び直してください。</span>`);
        // 失敗：権利未消費。数字もやり直し。
        if(asker==="ai"){ state.pendingAI=null; state.baseAI=null; setTimeout(()=>{ state.pendingAI = aiPickNumber(); aiChooseQuestion(); syncRevealButton(); },0); }
        else { state.pendingPL=null; state.basePL=null; renderGrid(); }
        state.qKey = null; state.qLocked = false; state.qEvaluated = false; clearQChosen();
        setQuestionUIEnabled(state.asker==="player"); syncRevealButton(); return;
      }else if(!avail.has(to)){
        log(`<b>${asker==="ai"?"AI":"あなた"}の権利: セブン</b> → <b>セブン失敗</b>（変換先 ${to} は使用済み）<span class="hint"> 質問と数字を選び直してください。</span>`);
        if(asker==="ai"){ state.pendingAI=null; state.baseAI=null; setTimeout(()=>{ state.pendingAI = aiPickNumber(); aiChooseQuestion(); syncRevealButton(); },0); }
        else { state.pendingPL=null; state.basePL=null; renderGrid(); }
        state.qKey = null; state.qLocked = false; state.qEvaluated = false; clearQChosen();
        setQuestionUIEnabled(state.asker==="player"); syncRevealButton(); return;
      }else{
        if(asker==="ai"){ state.pendingAI = to; log(`<b>AIの権利: セブン</b> → <b>${selfNum}</b> を <b>${to}</b> に変更（消費は元の ${selfNum} のみ）`); }
        else { state.pendingPL = to; log(`<b>あなたの権利: セブン</b> → <b>${selfNum}</b> を <b>${to}</b> に変更（消費は元の ${selfNum} のみ）`); }
      }
    }
    state.qEvaluated = true; state.qLocked = true; setQuestionUIEnabled(state.asker==="player");
    return;
  }

  if(def.type==="yn"){
    if(target==null) return;
    const truth = !!def.fn(target);
    if(asker==="ai"){
      const next=new Set(); for(const x of state.oppCandidates){ if(!!def.fn(x)===truth) next.add(x); }
      state.oppCandidates=next; renderLists();
      log(`<b>AIの質問: ${QLABEL[state.qKey]}</b> → <b>${truth?'Yes':'No'}</b>`);
    }else{
      log(`<b>あなたの質問: ${QLABEL[state.qKey]}</b> → <b>${truth?'Yes':'No'}</b>`);
    }
    state.qEvaluated = true; state.qLocked = true; setQuestionUIEnabled(state.asker==="player");
    return;
  }

  if(def.type==="mod4"){
    if(target==null) return;
    const r = ((target%4)+4)%4;
    if(asker==="ai"){
      const next=new Set(); for(const x of state.oppCandidates){ if(((x%4)+4)%4===r) next.add(x); }
      state.oppCandidates=next; renderLists();
      log(`<b>AIの質問: フォー</b> → <b>余り ${r}</b>`);
    }else{
      log(`<b>あなたの質問: フォー</b> → <b>余り ${r}</b>`);
    }
    state.qEvaluated = true; state.qLocked = true; setQuestionUIEnabled(state.asker==="player");
    return;
  }

  if(def.type==="mod5"){
    if(target==null) return;
    const r = ((target%5)+5)%5;
    if(asker==="ai"){
      const next=new Set(); for(const x of state.oppCandidates){ if(((x%5)+5)%5===r) next.add(x); }
      state.oppCandidates=next; renderLists();
      log(`<b>AIの質問: ファイブ</b> → <b>余り ${r}</b>`);
    }else{
      log(`<b>あなたの質問: ファイブ</b> → <b>余り ${r}</b>`);
    }
    state.qEvaluated = true; state.qLocked = true; setQuestionUIEnabled(state.asker==="player");
    return;
  }

  if(def.type==="setN"){
    if(asker==="player" && (!state.qSetN || state.qSetN.length===0)){
      return; // 入力待ち
    }
    let set = new Set(state.qSetN);
    if(asker==="ai"){ // AIは最適化した6候補を自動生成
      const cand = (state.oppCandidates.size? state.oppCandidates : new Set(Array.from({length:100},(_,i)=>i+1)));
      const auto = buildSetFromCandidates(cand, QDEF.six.n);
      set = new Set(auto); state.qSetN = auto;
    }
    const truth = set.has(target);
    if(asker==="ai"){
      const next=new Set(); for(const x of state.oppCandidates){ if(set.has(x)===truth) next.add(x); }
      state.oppCandidates=next; renderLists();
      log(`<b>AIの質問: シックス</b> [${state.qSetN.join(", ")}] → <b>${truth?'Yes':'No'}</b>`);
    }else{
      log(`<b>あなたの質問: シックス</b> [${state.qSetN.join(", ")}] → <b>${truth?'Yes':'No'}</b>`);
    }
    state.qEvaluated = true; state.qLocked = true; setQuestionUIEnabled(state.asker==="player");
    return;
  }
}

/* ========= 質問UI（あなた側） ========= */
document.querySelectorAll(".qbtn").forEach(btn=>{
  btn.addEventListener("click", ()=>{
    if(state.asker!=="player" || state.qLocked || state.revealed) return;
    document.querySelectorAll(".qbtn").forEach(b=>b.classList.remove("chosen"));
    btn.classList.add("chosen");
    state.qKey = btn.dataset.q; state.qAsker = "player";

    setInput.disabled = (state.qKey!=="six");
    if(state.qKey==="six"){
      state.qSetN=[]; setInput.value="";
      log(`<b>あなたの権利</b>: シックス（このターンはロック） <span class="hint">→ 下の欄に数字を最大6つ入力して確定</span>`);
      setInput.focus();
    }else{
      log(`<b>あなたの権利</b>: ${QLABEL[state.qKey]}（このターンはロック）`);
      evaluateQuestionImmediately();
    }
    syncRevealButton();
  });
});

// シックス入力確定
setInput.addEventListener("change", ()=>{
  if(state.qLocked) return;
  const vals = setInput.value.trim().split(/\s+/).filter(s=>s.length>0).map(s=>parseInt(s,10)).filter(n=>Number.isInteger(n)&&n>=1&&n<=100);
  state.qSetN = [...new Set(vals)].slice(0,6);
  setInput.value = state.qSetN.join(" ");
  log(`<span class="hint">シックス集合: [${state.qSetN.join(", ")}]</span>`);
  evaluateQuestionImmediately();
  syncRevealButton();
});

/* ========= AIの質問選択 ========= */
function splitScoreForQuestion(qKey, candSet){
  const def = QDEF[qKey]; if(!def) return -1;
  if(def.type==="mod5"){
    const bins=[0,0,0,0,0]; for(const x of candSet){ bins[((x%5)+5)%5]++; }
    return -Math.max(...bins);
  }
  if(def.type==="mod4"){
    const bins=[0,0,0,0]; for(const x of candSet){ bins[((x%4)+4)%4]++; }
    return -Math.max(...bins);
  }
  if(def.type==="setN"){
    const set = new Set(buildSetFromCandidates(candSet, def.n));
    let yes=0, no=0; for(const x of candSet){ if(set.has(x)) yes++; else no++; }
    return -Math.max(yes,no);
  }
  if(def.type==="yn"){
    let yes=0; for(const x of candSet){ if(def.fn(x)) yes++; } const no=candSet.size-yes; return -Math.max(yes,no);
  }
  if(def.type==="self" || qKey==="one"){ return -Infinity; }
  return -Infinity;
}
function aiChooseQuestion(){
  if(state.qLocked) return;
  const diff = $("#difficulty").value;

  if(diff==="hell" && state.asker==="ai"){
    const cand = (state.oppCandidates.size? state.oppCandidates : new Set(Array.from({length:100},(_,i)=>i+1)));
    const qCandidates = ["three","five","four","eight","six"]; // 情報系を優先
    let bestQ = "three", bestScore = -Infinity;
    for(const q of qCandidates){ const score = splitScoreForQuestion(q, cand); if(score>bestScore){ bestScore=score; bestQ=q; } }
    state.qKey = bestQ; state.qAsker = "ai";
    if(bestQ==="six"){ state.qSetN = buildSetFromCandidates(cand, QDEF.six.n); log(`<b>AIの質問</b>: シックス（候補: ${state.qSetN.join(", ")})`); }
    else { log(`<b>AIの質問</b>: ${QLABEL[bestQ]}`); }
    evaluateQuestionImmediately(); return;
  }

  if(diff==="expert" && state.asker==="ai"){
    state.qKey = (Math.random() < 0.7) ? "three" : "four"; // mod4も使う
    state.qAsker = "ai";
    log(`<b>AIの質問</b>: ${QLABEL[state.qKey]}`);
    evaluateQuestionImmediately(); return;
  }

  const order = [];
  const rnd=Math.random();
  if(rnd<0.15) order.push("five");
  else if(rnd<0.3) order.push("four");
  order.push("two","three","six","seven","eight","nine","one");

  for(const k of order){
    state.qKey = k; state.qAsker = "ai";
    if(k==="six"){ 
      state.qSetN = buildSetFromCandidates(state.oppCandidates, QDEF.six.n); 
      if(state.qSetN.length===0){ continue; }
      log(`<b>AIの質問</b>: シックス（候補: ${state.qSetN.join(", ")})`);
    }else{
      log(`<b>AIの質問</b>: ${QLABEL[k]}`);
    }
    evaluateQuestionImmediately(); return;
  }

  state.qKey = "three"; state.qAsker = "ai"; log(`<b>AIの質問</b>: ${QLABEL[state.qKey]}`); evaluateQuestionImmediately();
}

/* ========= ターン制御 ========= */
function nextTurn(){
  state.turn += 1; $("#turnNow").textContent = String(state.turn);

  if(state.turn===1){
    const starterSel=$("#starter").value;
    state.turnStarter = (starterSel==="random") ? (Math.random()<0.5?"player":"ai") : starterSel;
  }else{
    state.turnStarter = (state.turnStarter==="player") ? "ai" : "player";
  }
  state.asker = (state.turnStarter==="player") ? "ai" : "player";
  state.qAsker = null;
  $("#turnStarter").textContent = (state.turnStarter==="player") ? "あなた" : "AI";
  $("#asker").textContent = (state.asker==="player") ? "あなた" : "AI";

  state.pendingAI=null; state.pendingPL=null; state.baseAI=null; state.basePL=null;
  state.qKey=null; state.qLocked=false; state.qEvaluated=false; state.qSetN=[]; state.qAsker=null;
  state.revealed=false; setQuestionUIEnabled(state.asker==="player"); setButtons({reveal:false, cleanup:false});
  Array.from(gridEl.children).forEach(c=>c.classList.remove("selected"));

  if(state.deuce){ statusEl.textContent = "デュース中（Win by 2）。"; }
  else if(state.turn===1){ statusEl.textContent = `対局開始。先取本数は ${state.winTarget}。`; }

  if(state.turnStarter==="player"){ /* あなた先手：AIは質問者 */ }
  else { state.pendingAI = aiPickNumber(); }

  renderGrid(); renderLists();
}

/* あなたが数字を選んだとき */
function onPlayerPickedMaybeAdvance(){
  if(state.pendingPL==null){ syncRevealButton(); return; }
  if(state.pendingAI==null){ state.pendingAI = aiPickNumber(); }

  // ★ 追加：AIが質問者なら、ここでAIの質問を自動確定
  if(state.asker === "ai" && !state.qKey && !state.revealed){
    state.qAsker = "ai";
    aiChooseQuestion();           // 中で evaluateQuestionImmediately() まで走る
  }

  syncRevealButton();
}

/* ========= 公開→判定→自動削除 ========= */
function revealAndJudge(){
  if(state.revealed) return;
  if(state.pendingPL==null || state.pendingAI==null){ alert("両者の数字が未確定です。"); return; }

  if(!state.qKey){
    if(state.asker==="ai"){ aiChooseQuestion(); }
    else { alert("権利を選んでください。（質問者は後攻です）"); return; }
  }
  if(!state.qEvaluated) evaluateQuestionImmediately();

  // セブン失敗などで質問未確定になった場合は公開を中断してやり直し
  if(!state.qKey || !state.qEvaluated){
    log(`<span class="hint">※ 権利が未確定のため、公開を中断しました。質問と数字を選び直してください。</span>`);
    setQuestionUIEnabled(state.asker==="player");
    syncRevealButton();
    return;
  }

  state.qLocked = true; setQuestionUIEnabled(state.asker==="player");

  const ai = state.pendingAI, pl = state.pendingPL;
  let res="Draw";

  if(state.qKey==="one"){ // ワン特例
    const askerIsPlayer = (state.qAsker==="player");
    const askerNum = askerIsPlayer ? pl : ai;
    const otherNum = askerIsPlayer ? ai : pl;
    if(askerNum>=1 && askerNum<=9 && (askerNum%10)===(otherNum%10)){
      res = askerIsPlayer ? "Player" : "AI";
    }else{
      res = judgeCore(pl, ai);
    }
  }else{
    res = judgeCore(pl, ai);
  }

  if(res==="Player") state.score.you++;
  else if(res==="AI") state.score.ai++;
  else state.score.draw++;

  log(`<b>[公開]</b> AI=${ai} / You=${pl} → <b>${res}</b>`);
  updateScore();

  state.revealed = true;
  gridEl.classList.add("disabled");
  setButtons({reveal:false, cleanup:true});
  statusEl.textContent = "判定完了。数字は自動で削除されます。";

  cleanup(true);
}

/* ========= 先取本数＋デュースの終了判定 ========= */
function maybeFinishByTarget(){
  const Y=state.score.you, A=state.score.ai, T=state.winTarget;

  if(!state.deuce){
    if(Y>=T && A>=T){ state.deuce = true; log(`<b>=== デュース突入（Win by 2） ===</b>`); return false; }
    if((Y>=T || A>=T) && Math.abs(Y-A)===1){ return false; }
    if((Y>=T || A>=T) && Math.abs(Y-A)>=2){ endGame(); return true; }
    return false;
  }
  if(Math.abs(Y-A)>=2){ endGame(); return true; }
  return false;
}

function cleanup(){
  // 消費するのは「元カード」（base*）。自己操作で値が変わっていても元を削除する。
  const consumePL = (state.basePL!=null) ? state.basePL : state.pendingPL;
  const consumeAI = (state.baseAI!=null) ? state.baseAI : state.pendingAI;

  if(consumePL!=null && state.availablePL.has(consumePL)) state.availablePL.delete(consumePL);
  if(consumeAI!=null && state.availableAI.has(consumeAI)) state.availableAI.delete(consumeAI);

  if(consumeAI!=null) state.history.ai.push(consumeAI);
  if(consumePL!=null) state.history.player.push(consumePL);

  state.pendingAI=null; state.pendingPL=null; state.baseAI=null; state.basePL=null;
  state.qKey=null; state.qLocked=false; state.qEvaluated=false; state.qSetN=[]; state.qAsker=null;
  renderGrid(); renderLists();
  setButtons({reveal:false, cleanup:false});
  gridEl.classList.remove("disabled");

  if(!maybeFinishByTarget()) nextTurn();
}

function endGame(){
  const msg = `最終スコア：あなた ${state.score.you} - ${state.score.ai} AI`;
  statusEl.textContent = msg + (state.deuce ? "（デュースの末）" : "") + "　新しい対局で再開できます。";
  log(`<b>=== 終局 ===</b> ${msg}${state.deuce ? "（デュースの末）" : ""}`);
  $("#btnReveal").disabled = true; $("#btnCleanup").disabled = true;
}

/* ========= イベント ========= */
$("#btnReveal").addEventListener("click", ()=>{ revealAndJudge(); });
$("#btnCleanup").addEventListener("click", ()=>{ cleanup(); });
$("#btnNew").addEventListener("click", ()=>{ resetGame(); });

/* 初期起動 */
resetGame();
</script>
</body>
</html>
