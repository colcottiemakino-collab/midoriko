# -*- coding: utf-8 -*-
"""
Number Duel – Full Fixed Version
- 早期リーク完全封止：削除は「同時公開→判定→その後」のみ
- 述語は辞書で安定マップ（ツー/スリーなどの配線ズレ防止）
- AI質問→ユーザー回答は opponent_candidates にのみ反映（available は触らない）
- ログでデバッグ容易化
"""

from __future__ import annotations
from dataclasses import dataclass, field
from typing import Callable, Dict, List, Optional, Set, Tuple
import random
import sys

# =========================
# 述語（質問）レジストリ
# =========================

# 述語本体
PREDICATES: Dict[str, Callable[[int], bool]] = {
    "one":   lambda x: True,                 # 1で割り切れる（常にTrue）…デモ用
    "two":   lambda x: (x % 2 == 0),         # 偶数
    "three": lambda x: (x % 3 == 0),         # 3の倍数
    "five":  lambda x: (x % 5 == 0),         # 5の倍数
    "seven": lambda x: (x % 7 == 0),         # 7の倍数
    "nine":  lambda x: (x % 9 == 0),         # 9の倍数
    # “eight”はゲーム仕様に合わせて定義を選ぶ：
    # 例1：10の位が8 or 末尾8（80-89 or _8）→心理釣り系
    "eight": lambda x: (x // 10 == 8) or (x % 10 == 8),
}

# ラベルの正規化（絶対に配列順に依存しない）
ALIAS: Dict[str, str] = {
    # two
    "2": "two", "two": "two", "ツー": "two", "トゥー": "two", "偶数": "two",
    # three
    "3": "three", "three": "three", "スリー": "three", "三": "three",
    # five
    "5": "five", "five": "five", "ファイブ": "five", "五": "five",
    # seven
    "7": "seven", "seven": "seven", "セブン": "seven", "七": "seven",
    # eight
    "8": "eight", "eight": "eight", "エイト": "eight", "八": "eight",
    # nine
    "9": "nine", "nine": "nine", "ナイン": "nine", "九": "nine",
    # one
    "1": "one", "one": "one", "ワン": "one", "一": "one",
}

def resolve_predicate(label: str) -> Tuple[str, Callable[[int], bool]]:
    """ユーザー表示ラベル（日本語/数字/英語）→ 述語キーと関数に正規化"""
    key = ALIAS.get(label, label).lower()
    if key not in PREDICATES:
        raise KeyError(f"未知の質問ラベル: {label}（正規化キー: {key}）")
    return key, PREDICATES[key]

# =========================
# ユーティリティ
# =========================

def info_split_score(candidates: Set[int], pred: Callable[[int], bool]) -> float:
    """情報量っぽいスコア（分割が50:50に近いほど高評価）"""
    if not candidates:
        return -1.0
    t = sum(1 for x in candidates if pred(x))
    f = len(candidates) - t
    # 50:50 で1.0、片寄るほど0に近づく
    p = abs(t - f) / float(len(candidates))
    return 1.0 - p

def choose_best_question(candidates: Set[int], keys_priority: List[str]) -> str:
    """候補集合を二分しやすい質問を選ぶ。優先キーでタイも破る。"""
    best_key = None
    best_score = -1.0
    for k in keys_priority:
        pred = PREDICATES[k]
        s = info_split_score(candidates, pred)
        if s > best_score:
            best_score, best_key = s, k
    return best_key or keys_priority[0]

# =========================
# 戦術フック（数字選択）
# =========================

def ai_pick_conservative(available: Set[int]) -> int:
    """序盤は偶数かつ大きめをやや優先（釣りと牽制の中間）"""
    cand = [x for x in available if x % 2 == 0 and x >= 60]
    if cand:
        return random.choice(cand)
    return random.choice(tuple(available))

def ai_pick_three_drop(available: Set[int]) -> int:
    """三落とし定石の雰囲気（上から3刻みを志向）"""
    prio = [x for x in available if (x % 3 == 0 and x >= 75)]
    if prio:
        return max(prio)  # 上から抑える雰囲気
    return max(available) if available else 1

def ai_pick_90_tsur i(available: Set[int]) -> int:
    """90釣り定石の雰囲気（90筆頭、他デコイ）"""
    for k in [90, 88, 80, 85, 70, 99, 98, 96]:
        if k in available:
            return k
    return random.choice(tuple(available))

# =========================
# 記録用データクラス
# =========================

@dataclass
class TurnLog:
    turn: int
    question_key: Optional[str] = None
    question_label: Optional[str] = None
    answer: Optional[bool] = None
    candidates_before: Optional[int] = None
    candidates_after: Optional[int] = None
    ai_number: Optional[int] = None
    player_number: Optional[int] = None
    result: Optional[str] = None   # "Player"/"AI"/"Draw"

# =========================
# 本体
# =========================

class NumberDuel:
    def __init__(self, low: int = 1, high: int = 100, seed: Optional[int] = None):
        if seed is not None:
            random.seed(seed)

        self.low = low
        self.high = high

        # 使える数字（盤面の共有資源）…ターン終了時のみ更新！
        self.available: Set[int] = set(range(low, high + 1))

        # 相手（プレイヤー）の秘匿数字候補（AIの推定用）。質問でのみ削る。
        self.opponent_candidates: Set[int] = set(range(low, high + 1))

        # ペンディング選択（同時公開のため）
        self._pending_ai: Optional[int] = None
        self._pending_player: Optional[int] = None

        # スコア
        self.score_player = 0
        self.score_ai = 0
        self.draws = 0

        # ログ
        self.logs: List[TurnLog] = []

        # 質問の優先リスト（バランス取りやすい順）
        self.question_priority = ["two", "three", "five", "seven", "nine", "eight", "one"]

    # ---------- ターンの流れ ----------
    def ai_ask_question(self) -> Tuple[str, str]:
        """AIが Yes/No 質問を1つ選ぶ（available は触らない）"""
        key = choose_best_question(self.opponent_candidates, self.question_priority)
        label = key  # 表示用、必要なら日本語に置換してもよい
        # ログひな形追加
        self.logs.append(TurnLog(turn=len(self.logs) + 1, question_key=key, question_label=label))
        return key, label

    def apply_player_answer(self, question_key: str, answer_bool: bool) -> None:
        """プレイヤーがYes/No回答。opponent_candidatesのみ絞る。"""
        pred = PREDICATES[question_key]
        lg = self.logs[-1]
        lg.answer = answer_bool
        lg.candidates_before = len(self.opponent_candidates)

        # ここで available は**絶対に**触らない！ 釣りや質問は相手の候補推定だけ。
        self.opponent_candidates = {x for x in self.opponent_candidates if pred(x) == answer_bool}
        lg.candidates_after = len(self.opponent_candidates)

    def ai_select_number(self) -> None:
        """AIが今ターンに出す数字を“保留選択”する（削除しない）"""
        if not self.available:
            raise RuntimeError("数字が残っていません。")
        # ここで戦術を切替可能（例：序盤守備→中盤三落とし）
        # シンプルに候補数で切替する例
        if len(self.available) >= 50:
            choice = ai_pick_conservative(self.available)
        elif len(self.available) >= 25:
            choice = ai_pick_90_tsur i(self.available)
        else:
            choice = ai_pick_three_drop(self.available)

        if choice not in self.available:
            raise AssertionError("AIが未使用でない数字を選びました。")
        self._pending_ai = choice

    def player_select_number(self, n: int) -> None:
        """プレイヤーが今ターンに出す数字を“保留選択”する（削除しない）"""
        if n not in self.available:
            raise ValueError(f"{n} は使用できません（未使用のみ）。")
        self._pending_player = n

    def reveal_and_judge(self) -> Tuple[str, int, int]:
        """同時公開 → 判定（削除はまだしない）"""
        if self._pending_ai is None or self._pending_player is None:
            raise RuntimeError("公開の前に両者の選択が必要です。")
        ai_n = self._pending_ai
        pl_n = self._pending_player

        if pl_n > ai_n:
            res = "Player"
            self.score_player += 1
        elif pl_n < ai_n:
            res = "AI"
            self.score_ai += 1
        else:
            res = "Draw"
            self.draws += 1

        # ログ更新（削除前）
        lg = self.logs[-1]
        lg.ai_number = ai_n
        lg.player_number = pl_n
        lg.result = res

        return res, ai_n, pl_n

    def cleanup_after_resolution(self) -> None:
        """このタイミングで初めて available を削る（早期リーク防止の核心）"""
        if self._pending_ai is None or self._pending_player is None:
            raise RuntimeError("クリーンアップ前に公開が必要です。")
        # 使い終わった数字を盤面から除去（存在する場合のみ）
        if self._pending_ai in self.available:
            self.available.remove(self._pending_ai)
        if self._pending_player in self.available:
            self.available.remove(self._pending_player)

        # ペンディングをクリア（次ターンに持ち越さない）
        self._pending_ai = None
        self._pending_player = None

    def is_finished(self) -> bool:
        return len(self.available) == 0

    # ---------- デバッグ/可視化 ----------
    def last_log(self) -> Optional[TurnLog]:
        return self.logs[-1] if self.logs else None

# =========================
# CLI
# =========================

def ask_bool(prompt: str) -> bool:
    """y/n を True/False にする簡易入力"""
    while True:
        s = input(prompt + " [y/n]> ").strip().lower()
        if s in ("y", "yes", "t", "true", "1"):
            return True
        if s in ("n", "no", "f", "false", "0"):
            return False
        print("y か n を入力して。")

def main():
    print("=== Number Duel – Full Fixed Version ===")
    print("・削除は必ず『同時公開→判定→その後』で実行（早期リークは起きません）")
    print("・AIの質問は候補集合にのみ反映。available はターン終了まで不変です。\n")

    game = NumberDuel(low=1, high=100, seed=None)

    while not game.is_finished():
        turn_idx = len(game.logs) + 1
        print(f"--- Turn {turn_idx} ---  残り（未使用）: {len(game.available)}")

        # 1) AIが質問（Yes/No）
        q_key, q_label = game.ai_ask_question()
        # 表示を少し親切に
        jp = {
            "two":"偶数？", "three":"3の倍数？", "five":"5の倍数？",
            "seven":"7の倍数？", "nine":"9の倍数？",
            "eight":"80台または末尾8？", "one":"常にTrue（デモ）",
        }.get(q_key, q_key)
        print(f"AIの質問: {jp}  （key='{q_key}'）")
        ans = ask_bool("あなたの答えは？")

        # 1.5) 回答を適用（opponent_candidates のみ絞る）
        game.apply_player_answer(q_key, ans)
        lg = game.last_log()
        print(f"候補: {lg.candidates_before} → {lg.candidates_after}")

        # 2) AIは今ターンに出す数字を“保留選択”（available は触らない）
        game.ai_select_number()

        # 3) プレイヤーの数字を“保留選択”（available は触らない）
        while True:
            raw = input("あなたの数字（未使用）> ").strip()
            if raw.lower() in {"q", "quit", "exit"}:
                print("中断します。")
                sys.exit(0)
            try:
                n = int(raw)
            except ValueError:
                print("整数を入力して。")
                continue
            try:
                game.player_select_number(n)
                break
            except ValueError as e:
                print(e)
                continue

        # 4) 同時公開 → 判定（ここでも削除はしない）
        res, ai_n, pl_n = game.reveal_and_judge()
        print(f"[公開]  AI: {ai_n} / You: {pl_n}  → 結果: {res}")

        # 5) このタイミングで初めて available から削除（唯一の縮小ポイント）
        game.cleanup_after_resolution()

        # スコア表示
        print(f"Score  You {game.score_player} - {game.score_ai} AI  (Draw {game.draws})\n")

    print("=== 終局 ===")
    print(f"最終スコア: You {game.score_player} - {game.score_ai} AI / Draw {game.draws}")
    print("直近ログ（最大10ターン）:")
    for lg in game.logs[-10:]:
        qdisp = lg.question_key or "-"
        adisp = "-" if lg.answer is None else ("True" if lg.answer else "False")
        print(
            f" T{lg.turn}: Q={qdisp} A={adisp} "
            f"cand {lg.candidates_before}->{lg.candidates_after} "
            f"| AI {lg.ai_number} vs You {lg.player_number} → {lg.result}"
        )

if __name__ == "__main__":
    main()
