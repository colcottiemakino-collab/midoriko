<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ハンドレッド / Hundred ver 3.1.13-custom</title>
<style>
  :root{
    --bg:#0e1a12; --bg2:#122216; --panel:#152a1b; --accent:#35c46e; --accent-2:#2aa55b;
    --text:#e7ffe7; --muted:#b9d8c0; --warn:#ffd37a; --bad:#ff8a8a; --good:#8affb9;
    --grid-used:#2a3a2f; --btn:#173d26; --btn-hover:#1f5333; --border:#2f6848;
  }
  *{box-sizing:border-box}
  body{margin:0; background:linear-gradient(180deg,var(--bg),var(--bg2)); color:var(--text);
    font-family:ui-sans-serif,system-ui,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif;}
  header{padding:18px 20px; border-bottom:1px solid var(--border); display:flex; gap:12px; align-items:baseline; flex-wrap:wrap}
  h1{margin:0; font-size:20px; letter-spacing:.08em; color:var(--accent)}
  main{display:grid; grid-template-columns: 420px 1fr 360px; gap:16px; padding:16px}
  @media (max-width: 1200px){ main{grid-template-columns: 1fr} }

  .card{background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:14px;
    box-shadow: 0 10px 20px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.04);}
  .card h2{margin:0 0 10px; font-size:16px; color:var(--accent)}
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  select, button, input{
    background:var(--btn); color:var(--text); border:1px solid var(--border);
    border-radius:10px; padding:8px 10px; font-size:14px;
  }
  input{width:220px}
  button:hover{background:var(--btn-hover)}
  button:disabled{opacity:.45; cursor:not-allowed}
  .accent{background:var(--accent-2); border-color:transparent; color:#04210f; font-weight:700}
  .accent:hover{filter:brightness(1.05)}
  .muted{color:var(--muted); font-size:12px}

  .grid{display:grid; grid-template-columns: repeat(10, minmax(0,1fr)); gap:6px}
  .cell{
    padding:8px 0; text-align:center; border-radius:10px; border:1px solid var(--border);
    user-select:none; cursor:pointer; background:#13301e; transition:transform .05s ease, background .15s ease;
    font-variant-numeric:tabular-nums;
  }
  .cell:hover{transform:translateY(-1px); background:#184029}
  .cell.used{background:var(--grid-used); color:#6e8a78; border-style:dashed; cursor:not-allowed}
  .cell.selected{outline:2px solid var(--accent); box-shadow:0 0 0 2px rgba(53,196,110,.25) inset}
  .disabled{pointer-events:none; opacity:.6}

  .log{max-height:480px; overflow:auto; font-family:ui-monospace,Consolas,monospace; font-size:12px; line-height:1.5}
  .log b{color:var(--good)}
  .listbox{max-height:240px; overflow:auto; background:#0f2016; border:1px solid var(--border); border-radius:10px; padding:8px}
  .kbd{padding:2px 6px; border:1px solid var(--border); border-radius:6px; background:#0f2016; font-size:12px}
  .sep{border-top:1px solid var(--border); margin:10px 0; opacity:.5}

  .qbar button{padding:6px 8px; font-size:12px}
  .qbar .chosen{outline:2px solid var(--accent)}
  .qline{display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:6px}
  .hint{font-size:12px; color:#cfe9d5}

  .badge{display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid var(--border); background:#0f2016; font-size:11px; color:#cfe9d5}
</style>
</head>
<body>
<header>
  <h1>ハンドレッド / Hundred ver 3.1.13-custom</h1>
</header>

<main>
  <!-- 左：設定＆進行 -->
  <section class="card">
    <h2>セットアップ</h2>
    <div class="row" style="margin-bottom:8px">
      <label>難易度</label>
      <select id="difficulty">
        <option value="easy">easy</option>
        <option value="normal" selected>normal</option>
        <option value="hard">hard</option>
        <option value="expert">expert</option>
        <option value="hell">hell</option>
      </select>

      <label>先取本数</label>
      <select id="targetWins">
        <option value="5" selected>5</option>
        <option value="9">9</option>
        <option value="13">13</option>
      </select>
    </div>
    <div class="row" style="margin-bottom:8px">
      <label>先手</label>
      <select id="starter">
        <option value="player">あなた</option>
        <option value="ai">AI</option>
        <option value="random" selected>ランダム（初回のみ／以降交互）</option>
      </select>
      <button id="btnNew" class="accent">新しい対局</button>
    </div>
    <div id="status" class="muted">対局を開始してください。</div>

    <div class="sep"></div>

    <h2>ターン</h2>
    <div class="row" style="margin-bottom:8px">
      <div>ターン：<span id="turnNow">-</span>　
        先手：<span id="turnStarter">-</span>　
        質問者：<span id="asker">-</span></div>
    </div>
    <div class="row" style="margin-bottom:8px">
      <div>スコア（先取 <span id="winTargetLabel">5</span>）：あなた <span id="sYou">0</span> - <span id="sAI">0</span> AI　（引分 <span id="sD">0</span>）</div>
    </div>

    <div class="row" style="gap:12px">
      <span class="badge" id="badgePL">あなた: 未確定</span>
      <span class="badge" id="badgeAI">AI: 未確定</span>
    </div>

    <div class="row" style="margin-top:8px">
      <button id="btnReveal" disabled class="accent">同時公開 → 判定</button>
      <button id="btnCleanup" disabled>（自動削除中）</button>
    </div>

    <div class="sep"></div>

    <h2>あなたの質問（あなたが後攻＝質問者のとき）</h2>
    <div class="row qbar">
      <button class="qbtn" data-q="one"   disabled>ワン</button>
      <button class="qbtn" data-q="two"   disabled>ツー</button>
      <button class="qbtn" data-q="three" disabled>スリー</button>
      <button class="qbtn" data-q="four"  disabled>フォー</button>
      <button class="qbtn" data-q="five"  disabled>ファイブ</button>
      <button class="qbtn" data-q="six"   disabled>シックス</button>
      <button class="qbtn" data-q="seven" disabled>セブン</button>
      <button class="qbtn" data-q="eight" disabled>エイト</button>
      <button class="qbtn" data-q="nine"  disabled>ナイン</button>
    </div>
    <div class="qline">
      <label for="setInput" class="hint">シックス用（1〜100の数字を<b>最大6つ</b>、空白区切り）</label>
      <input id="setInput" placeholder="例: 17 33 70 98 41 12" disabled />
    </div>
    <div class="muted">
      ※ 後攻（質問者）のときだけ選べます。<br>
      ※ <b>質問系（3/4/5/6/8）は選択時に、あなたにだけ即結果表示</b>。相手に見えるのは公開時だけ。<br>
      ※ ワン・ツー・セブン・ナインは公開時に自分の数へ適用。
    </div>
  </section>

  <!-- 中：盤面（あなたの未使用の数字） -->
  <section class="card">
    <h2>盤面（あなたの未使用の数字）</h2>
    <div id="grid" class="grid"></div>
  </section>

  <!-- 右：相手情報＆ログ -->
  <section class="card">
    <h2>相手情報</h2>
    <div class="muted">右の一覧は<b>AIの未使用数字</b>。AIが質問者のときも<b>公開まで内容は伏せ</b>。</div>
    <div class="sep"></div>
    <div><b>AI未使用（=残り）</b></div>
    <div id="listAI" class="listbox"></div>
    <div class="sep"></div>
    <h2>ログ</h2>
    <div id="log" class="log"></div>
  </section>
</main>

<section class="card" style="margin:0 16px 16px">
  <h2>ルール</h2>
  <pre class="rules-raw">【基本ルール】
あなたとAIは、それぞれ1～100の数字カードを持っています。
先攻後攻ともに、数字カードを１つ伏せて出します。
せーのでめくって、数字がでかい方の勝ちです。
同じだったら引き分けになります。
１度使ったカードはもう使えません。

これを先攻後攻を交代しながら、先に決まった回数勝利すれば勝ちです。
ただしリードが１差のままでは決着せず、
両者が先取本数に到達（例：5-5）するとデュース（Win by 2）になります。

【応用ルール】
(1)すべての偶数は、すべての奇数に負けます。あらゆるルールに優先します。
(2)お互い３の倍数だった場合にかぎり、「より小さい方」が勝ちます。
　このルールは(1)より弱いです。
　９９と３なら３の勝ちですが、９９と６は９９の勝ちです。奇数なので。
(3)後述する「ワン」を利用した場合、成功すれば「ワン」が勝ちます。

【ライフナイン（後攻専用）】
後攻側プレイヤーは「ライフナイン」と呼ばれる９つの権利があります。
以下の中から、毎回どれか１つだけを使うことができます。

ワン    あなたが１～９を出し、相手の下1桁と一致したらあなたの勝利。
ツー    あなたの選んだ自分の数を +２する（上限なし）。変換先が使用済みでも使える。
スリー  相手が３の倍数か聞ける（Yes/No）
フォー  相手の数を４で割った余り（0〜3）を聞ける
ファイブ 相手の数を５で割った余り（0〜4）を聞ける
シックス あなたが最大６つの数字を指定し、そのいずれかかどうかを聞ける（Yes/No）
セブン  あなたの数字の「10 の位」を７にする（例: 53→73）。変換先が使用済みでも使える。
エイト  相手が80以上かどうかを聞ける（Yes/No）
ナイン  あなたの選んだ自分の数を９倍にする（上限なし）。変換先が使用済みでも使える。
</pre>
</section>

<script>
/* ========= 質問定義 ========= */
const QDEF = {
  one:   {type:"rule"},
  two:   {type:"self", op:"plus2"},
  three: {type:"yn",   fn:x => x%3===0},
  four:  {type:"mod4"},
  five:  {type:"mod5"},
  six:   {type:"setN", n:6},
  seven: {type:"self", op:"to70s"},
  eight: {type:"yn",   fn:x => x>=80},
  nine:  {type:"self", op:"times9"}
};
const QLABEL = {one:"ワン", two:"ツー", three:"スリー", four:"フォー", five:"ファイブ", six:"シックス", seven:"セブン", eight:"エイト", nine:"ナイン"};

/* ========= 状態 ========= */
const state = {
  difficulty: "normal",
  turn: 0,
  turnStarter: "player",
  asker: "ai",

  winTarget: 5,
  deuce: false,

  availablePL: new Set(),
  availableAI: new Set(),

  selPL: null, basePL: null,
  selAI: null, baseAI: null, aiStarterLocked: false,

  qKey: null, qAsker: null, qLocked: false,
  qSetN: [],
  qAnswerPrivate: null,
  qAIAutoSet: [],

  revealed:false,
  score: {you:0, ai:0, draw:0},
  history: {player:[], ai:[]}
};

const $ = sel => document.querySelector(sel);
const gridEl = $("#grid"), logEl = $("#log"), statusEl = $("#status");
const listAI=$("#listAI");
const setInput=$("#setInput");
const badgePL=$("#badgePL"), badgeAI=$("#badgeAI");

/* ========= ユーティリティ ========= */
function log(line){ const div=document.createElement("div"); div.innerHTML=line; logEl.appendChild(div); logEl.scrollTop=logEl.scrollHeight; }
function numArrayDesc(set){ return Array.from(set).sort((a,b)=>b-a); }
function renderLists(){ if(listAI) listAI.textContent = numArrayDesc(state.availableAI).join(", "); }
function updateBadges(){
  const plText = state.basePL!=null
    ? `確定(${state.basePL})`
    : (state.selPL ? `選択中(${state.selPL})` : "未確定");
  badgePL.textContent = `あなた: ${plText}`;

  let aiText = "未確定";
  if(state.revealed){
    aiText = state.baseAI!=null ? `確定(${state.baseAI})` : (state.selAI?`選択中(${state.selAI})`:"未確定");
  }else{
    if(state.baseAI!=null || state.selAI!=null) aiText = (state.baseAI!=null? "確定(非公開)" : "選択中(非公開)");
  }
  badgeAI.textContent = `AI: ${aiText}`;
}
function renderGrid(){
  gridEl.innerHTML="";
  for(let n=100;n>=1;--n){
    const cell=document.createElement("div");
    cell.className="cell"; cell.textContent=n;
    if(!state.availablePL.has(n)){
      cell.classList.add("used");
    }else{
      cell.addEventListener("click", ()=>{
        if(state.revealed) return;
        state.selPL = (state.selPL===n ? null : n);
        Array.from(gridEl.children).forEach(c=>c.classList.remove("selected"));
        if(state.selPL===n) cell.classList.add("selected");
        updateBadges(); updateControls();
      });
    }
    gridEl.appendChild(cell);
  }
}
function updateScore(){ $("#sYou").textContent=state.score.you; $("#sAI").textContent=state.score.ai; $("#sD").textContent=state.score.draw; }

/* ========= 初期化 ========= */
function resetGame(){
  state.availablePL = new Set(Array.from({length:100},(_,i)=>i+1));
  state.availableAI = new Set(Array.from({length:100},(_,i)=>i+1));

  state.selPL=null; state.basePL=null;
  state.selAI=null; state.baseAI=null; state.aiStarterLocked=false;

  state.qKey=null; state.qAsker=null; state.qLocked=false; state.qSetN=[]; state.qAnswerPrivate=null; state.qAIAutoSet=[];
  state.revealed=false; state.history={player:[], ai:[]};
  state.score={you:0, ai:0, draw:0};

  state.winTarget = parseInt($("#targetWins").value,10);
  $("#winTargetLabel").textContent = String(state.winTarget);

  const starterSel = $("#starter").value;
  state.turnStarter = (starterSel==="random") ? (Math.random()<0.5?"player":"ai") : starterSel;
  state.asker = (state.turnStarter==="player") ? "ai" : "player";

  $("#turnNow").textContent = "0";
  logEl.innerHTML="";
  statusEl.textContent = "対局開始。ボタンは『同時公開 → 判定』のみ。押した瞬間に未確定を自動処理して公開。";
  renderGrid(); renderLists(); updateScore(); updateBadges();
  nextTurn();
}

/* ========= 判定 ========= */
function judgeCore(pl, ai){
  const aiOdd=(ai%2===1), plOdd=(pl%2===1);
  if(aiOdd!==plOdd){ return plOdd ? "Player" : "AI"; }
  const aiM3=(ai%3===0), plM3=(pl%3===0);
  if(aiM3 && plM3){
    if(pl<ai) return "Player";
    if(pl>ai) return "AI";
    return "Draw";
  }
  if(pl>ai) return "Player";
  if(pl<ai) return "AI";
  return "Draw";
}

/* ========= 選択ヘルパ ========= */
function pickRandom(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function arrFrom(set){ return [...set]; }
function oddsFrom(set){ return [...set].filter(x=>x%2===1); }
function evensFrom(set){ return [...set].filter(x=>x%2===0); }
function anyFrom(set){ const a=arrFrom(set); return a.length ? Math.max(...a) : null; }
function oddsLargePref(set){
  const o=oddsFrom(set); if(!o.length) return null;
  const sorted=o.sort((a,b)=>b-a); const k=Math.max(1,Math.floor(sorted.length*0.3));
  return pickRandom(sorted.slice(0,k));
}
function oddsSmallPref(set){
  const o=oddsFrom(set); if(!o.length) return null;
  const sorted=o.sort((a,b)=>a-b); const k=Math.max(1,Math.floor(sorted.length*0.3));
  return pickRandom(sorted.slice(0,k));
}
function oddsLargeExcept3Small(set){
  const o=oddsFrom(set); if(!o.length) return null;
  const m3=o.filter(x=>x%3===0).sort((a,b)=>a-b);
  const non=o.filter(x=>x%3!==0).sort((a,b)=>b-a);
  return non[0]??m3[0]??null;
}
function pickOddGE(set, th){ const cand=[...set].filter(x=>x%2===1 && x>=th).sort((a,b)=>b-a); return cand[0]??null; }
function firstAvailable(set, pred){ for(const x of [...set].sort((a,b)=>a-b)){ if(pred(x)) return x; } return null; }
function filterByOnesDigit(arr, d){ return arr.filter(x=>x%10===d); }

/* ========= 自己変換（公開時に適用） ========= */
function applySelfOp(num, op){
  if(num==null) return null;
  if(op==="plus2") return num + 2;
  if(op==="times9") return num * 9;
  if(op==="to70s") return 70 + (num % 10);
  return num;
}
function descSelf(op){
  if(op==="plus2") return "＋2";
  if(op==="times9") return "×9";
  if(op==="to70s") return "→70＋下一桁";
  return "";
}

/* ========= AI: 先手確定（AIが先手のとき、ターン開始時に選んで保持） ========= */
function aiPickStarterAndHold(){
  const diff = $("#difficulty").value;
  let pick=null;

  if(diff==="expert"){
    pick = pickOddGE(state.availableAI, 70)
        ?? firstAvailable(state.availableAI, x=>x%2===1 && x%3===0 && x<50)
        ?? oddsLargePref(state.availableAI)
        ?? oddsSmallPref(state.availableAI);
  }else if(diff==="hell"){
    if(Math.random()<0.15){
      const ev90 = evensFrom(state.availableAI).filter(x=>x>=90).sort((a,b)=>b-a);
      if(ev90.length) pick = ev90[0];
    }
    if(pick==null){
      const ev80 = evensFrom(state.availableAI).filter(x=>x>=80).sort((a,b)=>b-a);
      if(ev80.length) pick = ev80[0];
    }
    if(pick==null){
      pick = pickOddGE(state.availableAI, 70)
          ?? firstAvailable(state.availableAI, x=>x%2===1 && x%3===0 && x<50)
          ?? oddsLargePref(state.availableAI)
          ?? oddsSmallPref(state.availableAI);
    }
  }else if(diff==="easy"){
    const o=oddsFrom(state.availableAI);
    pick = o.length? pickRandom(o) : anyFrom(state.availableAI);
  }else if(diff==="normal"){
    pick = oddsLargePref(state.availableAI) ?? anyFrom(state.availableAI);
  }else if(diff==="hard"){
    pick = oddsLargeExcept3Small(state.availableAI) ?? anyFrom(state.availableAI);
  }

  if(pick==null) pick = anyFrom(state.availableAI); // 最終フォールバック
  state.selAI = pick; state.baseAI = pick; state.aiStarterLocked = true;
  updateBadges();
}

/* ========= Expert後攻の数字選択ポリシー（関数化） ========= */
function pickByExpertFollowerPolicy(avail){
  const largeOdd = ()=> oddsLargePref(avail) ?? oddsSmallPref(avail);
  const smallOdd = ()=> oddsSmallPref(avail) ?? oddsLargePref(avail);
  let pick=null;

  switch(state.qKey){
    case "one": {
      const pool=[1,5,7].filter(x=>avail.has(x)); pick = pool.length? pickRandom(pool): largeOdd(); break;
    }
    case "two": {
      pick = largeOdd();
      if(!pick){
        const cand=[...avail].filter(x=>x%2===1 && x%3===1).sort((a,b)=>a-b); // +2で3倍数
        pick = cand[0]??null;
      }
      break;
    }
    case "three": {
      if(state.qAnswerPrivate===true){
        const small3=[...avail].filter(x=>x%2===1 && x%3===0).sort((a,b)=>a-b);
        pick = small3[0]??null;
      }else{
        const bigNon3=[...avail].filter(x=>x%2===1 && x%3!==0).sort((a,b)=>b-a);
        pick = bigNon3[0]??null;
      }
      break;
    }
    case "four": { pick = largeOdd(); break; }
    case "five": {
      const r = state.qAnswerPrivate; // 0..4
      const mapping = {0:7,1:3,2:9,3:5,4:1};
      if(typeof r==="number"){
        const pref = mapping[r];
        const cand = oddsFrom(avail).sort((a,b)=>b-a);
        const sub = filterByOnesDigit(cand, pref);
        pick = sub[0]??cand[0]??null;
      }
      if(!pick) pick = largeOdd();
      break;
    }
    case "six": { pick = largeOdd(); break; }
    case "seven": {
      const fav=[17,19,29,37,47,49,59].filter(x=>avail.has(x));
      pick = fav.length? pickRandom(fav): largeOdd(); break;
    }
    case "eight": { pick = largeOdd(); break; }
    case "nine": {
      const cand=[...avail].filter(x=>x%2===1 && x>=13 && x%3!==0).sort((a,b)=>a-b);
      pick = cand[0]??smallOdd(); break;
    }
    default: pick = largeOdd();
  }
  return pick ?? anyFrom(avail);
}

/* ========= AI: 後攻のライフナイン選択（公開直前に一気にやる） ========= */
function aiChooseQuestionAndLockAfterPlayerStarterLocked(){
  const diff = $("#difficulty").value;
  let key=null;
  if(diff==="hell"){
    const base = ["two","three","five","nine"];
    const pool = (state.turn > 10) ? [...base,"seven"] : base;
    key = pickRandom(pool);
  }else if(diff==="expert"){
    let pool = ["one","two","three","four","five","six","seven","eight","nine"];
    const has157 = [1,5,7].some(x=>state.availableAI.has(x));
    if(!has157) pool = pool.filter(k=>k!=="one");
    key = pickRandom(pool);
  }else{
    const pool = ["one","two","three","four","five","six","seven","eight","nine"];
    key = pickRandom(pool);
  }
  state.qKey = key; state.qAsker = "ai"; state.qLocked = true;

  // 質問系はAIだけに即結果（ログには出さない）
  state.qAnswerPrivate = null; state.qAIAutoSet=[];
  if(["three","four","five","six","eight"].includes(key)){
    const target = state.basePL; // 先攻プレイヤーの確定値
    if(key==="three"){ state.qAnswerPrivate = (target%3===0); }
    if(key==="four"){  state.qAnswerPrivate = ((target%4)+4)%4; }
    if(key==="five"){  state.qAnswerPrivate = ((target%5)+5)%5; }
    if(key==="eight"){ state.qAnswerPrivate = (target>=80); }
    if(key==="six"){
      const all = Array.from({length:100},(_,i)=>i+1);
      const picks=[]; for(let i=1;i<=6;i++){ const p=i/7; picks.push(all[Math.floor(all.length*p)]); }
      state.qAIAutoSet = [...new Set(picks)];
      state.qAnswerPrivate = new Set(state.qAIAutoSet).has(target);
    }
  }

  // 数字確定（AIは回答に基づき基底数字を決める）
  aiPickFollowerAndLockByPolicy();
}

function aiPickFollowerAndLockByPolicy(){
  const diff = $("#difficulty").value;
  let pick=null;
  const avail = state.availableAI;

  if(diff==="expert"){
    pick = pickByExpertFollowerPolicy(avail);
  }else if(diff==="hell"){
    // 後攻時の数字選択は expert と同じ方針（再帰禁止）
    pick = pickByExpertFollowerPolicy(avail);
  }else if(diff==="easy"){
    const o=oddsFrom(avail);
    pick = o.length? pickRandom(o): anyFrom(avail);
  }else if(diff==="normal"){
    pick = oddsLargePref(avail) ?? anyFrom(avail);
  }else if(diff==="hard"){
    pick = oddsLargeExcept3Small(avail) ?? anyFrom(avail);
  }

  if(pick==null) pick = anyFrom(avail); // 最終フォールバック（偶数でも可）
  state.selAI = pick; state.baseAI = pick;
  updateBadges();
}

/* ========= プレイヤーUI（後攻時の質問） ========= */
document.querySelectorAll(".qbtn").forEach(btn=>{
  btn.addEventListener("click", ()=>{
    if(state.asker!=="player" || state.qLocked || state.revealed) return;
    if(!state.aiStarterLocked){ return; }
    document.querySelectorAll(".qbtn").forEach(b=>b.classList.remove("chosen"));
    btn.classList.add("chosen");
    state.qKey = btn.dataset.q; state.qAsker = "player";

    if(state.qKey==="six"){
      state.qSetN=[]; setInput.value=""; setInput.disabled=false;
      log(`<b>あなたの権利</b>: シックスを選択。集合を入力してください。`);
    }else{
      evalPlayerQuestionPreview();
      state.qLocked = true; updateControls();
    }
  });
});

function evalPlayerQuestionPreview(){
  const def = QDEF[state.qKey];
  if(!def) return;
  const target = state.baseAI; // 先攻AIの確定値
  if(def.type==="yn"){
    const truth = !!def.fn(target);
    state.qAnswerPrivate = truth;
    log(`<b>あなたの質問: ${QLABEL[state.qKey]}</b> → <b>${truth?'Yes':'No'}</b>（相手には非公開）`);
  }else if(def.type==="mod4"){
    const r=((target%4)+4)%4; state.qAnswerPrivate=r;
    log(`<b>あなたの質問: フォー</b> → <b>余り ${r}</b>（相手には非公開）`);
  }else if(def.type==="mod5"){
    const r=((target%5)+5)%5; state.qAnswerPrivate=r;
    log(`<b>あなたの質問: ファイブ</b> → <b>余り ${r}</b>（相手には非公開）`);
  }else{
    log(`<b>あなたの権利</b>: ${QLABEL[state.qKey]} を選択（効果は公開時に適用／相手には非公開）`);
  }
}

setInput.addEventListener("change", ()=>{
  if(state.asker!=="player" || state.qKey!=="six" || state.qLocked || state.revealed) return;
  const vals = setInput.value.trim().split(/\s+/).filter(s=>s.length>0).map(s=>parseInt(s,10)).filter(n=>Number.isInteger(n)&&n>=1&&n<=100);
  state.qSetN = [...new Set(vals)].slice(0,6);
  setInput.value = state.qSetN.join(" ");
  const truth = new Set(state.qSetN).has(state.baseAI);
  state.qAnswerPrivate = truth;
  log(`<b>あなたの質問: シックス</b> [${state.qSetN.join(", ")}] → <b>${truth?'Yes':'No'}</b>（相手には非公開）`);
  state.qLocked = true; updateControls();
});

/* ========= ターン制御 ========= */
function nextTurn(){
  state.turn += 1; $("#turnNow").textContent = String(state.turn);

  if(state.turn===1){
    const starterSel=$("#starter").value;
    state.turnStarter = (starterSel==="random") ? (Math.random()<0.5?"player":"ai") : starterSel;
  }else{
    state.turnStarter = (state.turnStarter==="player") ? "ai" : "player";
  }
  state.asker = (state.turnStarter==="player") ? "ai" : "player";
  $("#turnStarter").textContent = (state.turnStarter==="player") ? "あなた" : "AI";
  $("#asker").textContent = (state.asker==="player") ? "あなた" : "AI";

  state.selPL=null; state.basePL=null;
  state.selAI=null; state.baseAI=null; state.aiStarterLocked=false;
  state.qKey=null; state.qAsker=null; state.qLocked=false; state.qSetN=[]; state.qAnswerPrivate=null; state.qAIAutoSet=[];
  state.revealed=false;

  Array.from(gridEl.children).forEach(c=>c.classList.remove("selected"));

  if(state.deuce){ statusEl.textContent = "デュース中（Win by 2）。"; }
  else if(state.turn===1){ statusEl.textContent = `対局開始。先取本数は ${state.winTarget}。`; }

  if(state.turnStarter==="ai"){ aiPickStarterAndHold(); log(`<span class="hint">AIが先手の数字を決定（非公開）</span>`); }

  renderGrid(); renderLists(); updateBadges(); updateControls();
}

/* ========= 公開（ワンボタンで前処理→公開→判定） ========= */
function revealAndJudge(){
  if(state.revealed) return;

  if(state.selPL==null && state.basePL==null){
    alert("あなたの数字を選んでください。"); return;
  }

  if(state.turnStarter==="player"){
    if(state.basePL==null){ state.basePL = state.selPL; }
    if(!state.qLocked || state.qAsker!=="ai"){ aiChooseQuestionAndLockAfterPlayerStarterLocked(); }
    if(state.baseAI==null){
      // 念押しフォールバック
      aiPickFollowerAndLockByPolicy();
    }
    if(state.baseAI==null){ alert("AIの手が確定できませんでした。"); return; }
  }else{
    if(!state.aiStarterLocked){ aiPickStarterAndHold(); }
    if(!state.qLocked || state.qAsker!=="player"){
      alert("あなたのライフナインを選んでください。"); return;
    }
    if(state.basePL==null){ state.basePL = state.selPL; }
    if(state.basePL==null){ alert("あなたの数字を選んでください。"); return; }
  }

  // 公開ログ：AIの質問はこのタイミングで開示
  if(state.qAsker==="ai"){
    const def = QDEF[state.qKey];
    if(def.type==="yn"){
      log(`<b>AIの質問: ${QLABEL[state.qKey]}</b> → <b>${state.qAnswerPrivate?'Yes':'No'}</b>`);
    }else if(def.type==="mod4"){
      log(`<b>AIの質問: フォー</b> → <b>余り ${state.qAnswerPrivate}</b>`);
    }else if(def.type==="mod5"){
      log(`<b>AIの質問: ファイブ</b> → <b>余り ${state.qAnswerPrivate}</b>`);
    }else if(def.type==="setN"){
      log(`<b>AIの質問: シックス</b> [${state.qAIAutoSet.join(", ")}] → <b>${state.qAnswerPrivate?'Yes':'No'}</b>`);
    }else if(def.type==="self"){
      log(`<b>AIの権利: ${QLABEL[state.qKey]}</b>（効果はこれから自分の数に適用）`);
    }else if(def.type==="rule"){
      log(`<b>AIの権利: ${QLABEL[state.qKey]}</b>（判定はこれから適用）`);
    }
  }else if(state.qAsker==="player"){
    if(["three","four","five","six","eight"].includes(state.qKey)){
      const shown = (state.qKey==="three"||state.qKey==="eight") ? (state.qAnswerPrivate?'Yes':'No') : state.qAnswerPrivate;
      log(`<span class="hint">公開: あなたの${QLABEL[state.qKey]}の結果が相手に開示されました（<b>${shown}</b>）</span>`);
    }else{
      log(`<span class="hint">公開: あなたが ${QLABEL[state.qKey]} を使ったことが相手に開示されました</span>`);
    }
  }

  // 自己変換はここで適用
  let pl = state.basePL, ai = state.baseAI;
  const def = QDEF[state.qKey] || null;

  if(def && def.type==="self"){
    if(state.qAsker==="player"){
      pl = applySelfOp(pl, def.op);
      log(`<b>あなたの権利: ${QLABEL[state.qKey]}</b> → 自分の数 ${descSelf(def.op)} = <b>${pl}</b>`);
    }else{
      ai = applySelfOp(ai, def.op);
      log(`<b>AIの権利: ${QLABEL[state.qKey]}</b> → 自分の数 ${descSelf(def.op)} = <b>${ai}</b>`);
    }
  }

  let res="Draw";
  if(def && state.qKey==="one"){
    const askerIsPlayer = (state.qAsker==="player");
    const askerNum = askerIsPlayer ? pl : ai;
    const otherNum = askerIsPlayer ? ai : pl;
    if(askerNum>=1 && askerNum<=9 && (askerNum%10)===(otherNum%10)){
      res = askerIsPlayer ? "Player" : "AI";
    }else{
      res = judgeCore(pl, ai);
    }
  }else{
    res = judgeCore(pl, ai);
  }

  if(res==="Player") state.score.you++;
  else if(res==="AI") state.score.ai++;
  else state.score.draw++;

  log(`<b>[公開]</b> AI=${ai} / You=${pl} → <b>${res}</b>`);
  updateScore();

  state.revealed = true;
  $("#btnReveal").disabled = true; $("#btnCleanup").disabled = false;
  statusEl.textContent = "判定完了。数字は自動で削除されます。";
  cleanup();
}

/* ========= 先取＋デュース ========= */
function maybeFinishByTarget(){
  const Y=state.score.you, A=state.score.ai, T=state.winTarget;

  if(!state.deuce){
    if(Y>=T && A>=T){ state.deuce = true; log(`<b>=== デュース突入（Win by 2） ===</b>`); return false; }
    if((Y>=T || A>=T) && Math.abs(Y-A)===1){ return false; }
    if((Y>=T || A>=T) && Math.abs(Y-A)>=2){ endGame(); return true; }
    return false;
  }
  if(Math.abs(Y-A)>=2){ endGame(); return true; }
  return false;
}

function cleanup(){
  if(state.basePL!=null && state.availablePL.has(state.basePL)) state.availablePL.delete(state.basePL);
  if(state.baseAI!=null && state.availableAI.has(state.baseAI)) state.availableAI.delete(state.baseAI);

  if(state.baseAI!=null) state.history.ai.push(state.baseAI);
  if(state.basePL!=null) state.history.player.push(state.basePL);

  renderGrid(); renderLists(); updateBadges();
  $("#btnCleanup").disabled = true;

  if(!maybeFinishByTarget()) nextTurn();
}

function endGame(){
  const msg = `最終スコア：あなた ${state.score.you} - ${state.score.ai} AI`;
  statusEl.textContent = msg + (state.deuce ? "（デュースの末）" : "") + "　新しい対局で再開できます。";
  log(`<b>=== 終局 ===</b> ${msg}${state.deuce ? "（デュースの末）" : ""}`);
  $("#btnReveal").disabled = true; $("#btnCleanup").disabled = true;
}

/* ========= コントロール活性制御 ========= */
function updateControls(){
  const qEnable = (state.asker==="player" && !state.revealed && state.aiStarterLocked);
  document.querySelectorAll(".qbtn").forEach(b=>b.disabled = !qEnable || state.qLocked);
  setInput.disabled = !(qEnable && state.qKey==="six" && !state.qLocked);

  const canReveal = !state.revealed && (state.selPL!=null || state.basePL!=null);
  $("#btnReveal").disabled = !canReveal;

  updateBadges();
}

/* ========= イベント ========= */
$("#btnReveal").addEventListener("click", revealAndJudge);
$("#btnCleanup").addEventListener("click", cleanup);
$("#btnNew").addEventListener("click", resetGame);

/* 初期起動 */
resetGame();
</script>
</body>
</html>
