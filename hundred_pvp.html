<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ハンドレッド / Hundred PvP ver 3.4.0</title>
<style>
  :root{
    --bg:#0e1a12; --bg2:#122216; --panel:#152a1b; --accent:#35c46e; --accent-2:#2aa55b;
    --text:#e7ffe7; --muted:#b9d8c0; --warn:#ffd37a; --bad:#ff8a8a; --good:#8affb9;
    --grid-used:#2a3a2f; --btn:#173d26; --btn-hover:#1f5333; --border:#2f6848;
  }
  *{box-sizing:border-box}
  body{margin:0; background:linear-gradient(180deg,var(--bg),var(--bg2)); color:var(--text);
    font-family:ui-sans-serif,system-ui,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif;}
  header{padding:18px 20px; border-bottom:1px solid var(--border); display:flex; gap:12px; align-items:baseline; flex-wrap:wrap}
  h1{margin:0; font-size:20px; letter-spacing:.08em; color:var(--accent)}
  main{display:grid; grid-template-columns: 420px 1fr 360px; gap:16px; padding:16px}
  @media (max-width: 1100px){ main{grid-template-columns: 1fr} }

  .card{background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:14px;
    box-shadow: 0 10px 20px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.04);}
  .card h2{margin:0 0 10px; font-size:16px; color:var(--accent)}
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  select, button, input{
    background:var(--btn); color:var(--text); border:1px solid var(--border);
    border-radius:10px; padding:8px 10px; font-size:14px; touch-action:manipulation;
  }
  input{width:220px}
  button:hover{background:var(--btn-hover)}
  button:disabled{opacity:.45; cursor:not-allowed}
  .accent{background:var(--accent-2); border-color:transparent; color:#04210f; font-weight:700}
  .muted{color:var(--muted); font-size:12px}

  /* 数字グリッド：10列固定・セルは画面幅に応じて縮小（スマホで横スクロールなし） */
  .grid{display:grid; grid-template-columns: repeat(10, minmax(0,1fr)); gap:6px}
  .cell{
    padding: clamp(6px, 1.4vw, 10px) 0;
    text-align:center; border-radius:10px; border:1px solid var(--border);
    user-select:none; cursor:pointer; background:#13301e; transition:transform .05s ease, background .15s ease;
    font-variant-numeric:tabular-nums; font-size: clamp(11px, 2.8vw, 16px);
  }
  .cell:hover{transform:translateY(-1px); background:#184029}
  .cell.used{background:var(--grid-used); color:#6e8a78; border-style:dashed; cursor:not-allowed}
  .cell.selected{outline:2px solid var(--accent); box-shadow:0 0 0 2px rgba(53,196,110,.25) inset}

  .log{max-height:480px; overflow:auto; font-family:ui-monospace,Consolas,monospace; font-size:12px; line-height:1.5}
  .log b{color:var(--good)}
  .listbox{max-height:240px; overflow:auto; background:#0f2016; border:1px solid var(--border); border-radius:10px; padding:8px}
  .qbar button{padding:6px 8px; font-size:12px}
  .qbar .chosen{outline:2px solid var(--accent)}
  .qline{display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:6px}
  .hint{font-size:12px; color:#cfe9d5}
  .badge{display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid var(--border); background:#0f2016; font-size:11px; color:#cfe9d5}
  .sep{border-top:1px solid var(--border); margin:10px 0; opacity:.5}
  .pass{display:block; text-align:center; padding:10px; border:1px dashed var(--border); border-radius:12px; margin-top:10px; font-weight:700; color:var(--warn)}
</style>
</head>
<body>
<header>
  <h1>ハンドレッド / Hundred PvP ver 3.4.0（人間×人間／1台交互）</h1>
</header>

<main>
  <!-- 左：設定＆進行 -->
  <section class="card">
    <h2>セットアップ</h2>
    <div class="row" style="margin-bottom:8px">
      <label>先取本数</label>
      <select id="targetWins">
        <option value="5" selected>5</option>
        <option value="9">9</option>
        <option value="13">13</option>
      </select>
      <label>先手</label>
      <select id="starter">
        <option value="p1" selected>P1</option>
        <option value="p2">P2</option>
        <option value="random">ランダム（初回のみ／以降交互）</option>
      </select>
      <button id="btnNew" class="accent">新しい対局</button>
    </div>
    <div id="status" class="muted">対局を開始してください。</div>

    <div class="sep"></div>

    <h2>ターン／スコア</h2>
    <div class="row" style="margin-bottom:8px">
      <div>ターン：<span id="turnNow">-</span>　
        先攻：<span id="turnStarter">-</span>　
        後攻：<span id="asker">-</span></div>
    </div>
    <div class="row" style="margin-bottom:8px">
      <div>スコア（先取 <span id="winTargetLabel">5</span>）：P1 <span id="sP1">0</span> - <span id="sP2">0</span> P2　（引分 <span id="sD">0</span>）</div>
    </div>

    <div class="row" style="gap:12px">
      <span class="badge" id="badgeP1">P1: 未確定</span>
      <span class="badge" id="badgeP2">P2: 未確定</span>
    </div>

    <div class="row" style="margin-top:8px; gap:8px">
      <button id="btnLock" class="accent" disabled>先攻決定</button>
      <button id="btnReveal" class="accent" disabled>後攻決定</button>
    </div>

    <div class="sep"></div>

    <h2>後攻の権利（ライフナイン）</h2>
    <div class="muted">後攻プレイヤーだけが毎ターン1つ使えます（質問系は先に後攻だけ結果表示）。</div>
    <div class="row qbar" style="margin-top:8px">
      <button class="qbtn" data-q="one"   disabled>ワン</button>
      <button class="qbtn" data-q="two"   disabled>ツー</button>
      <button class="qbtn" data-q="three" disabled>スリー</button>
      <button class="qbtn" data-q="four"  disabled>フォー</button>
      <button class="qbtn" data-q="five"  disabled>ファイブ</button>
      <button class="qbtn" data-q="six"   disabled>シックス</button>
      <button class="qbtn" data-q="seven" disabled>セブン</button>
      <button class="qbtn" data-q="eight" disabled>エイト</button>
      <button class="qbtn" data-q="nine"  disabled>ナイン</button>
    </div>
    <div class="qline">
      <label for="setInput" class="hint">シックス用（1〜100の数字を<b>最大6つ</b>、空白区切り）</label>
      <input id="setInput" placeholder="例: 17 33 70 98 41 12" disabled />
    </div>

    <div class="pass" id="passNote">— 今は <b>P1</b> のターンです —</div>
  </section>

  <!-- 中央：盤面（いま操作中の人の未使用だけを表示） -->
  <section class="card">
    <h2>盤面（いま操作中の人の未使用）</h2>
    <div id="grid" class="grid"></div>
  </section>

  <!-- 右：相手未使用＋ログ -->
  <section class="card">
    <h2>相手情報</h2>
    <div class="muted">この一覧は常に<b>相手の未使用</b>を表示（公開情報）。先攻/後攻の入替に合わせて自動切替。</div>
    <div class="sep"></div>
    <div><b>相手未使用（=残り）</b></div>
    <div id="listOpponent" class="listbox"></div>
    <div class="sep"></div>
    <h2>ログ</h2>
    <div id="log" class="log"></div>
  </section>
</main>

<script>
/* ========= 質問定義 ========= */
const QDEF = {
  one:   {type:"rule"},
  two:   {type:"self", op:"plus2"},
  three: {type:"yn",   fn:x => x%3===0},
  four:  {type:"mod4"},
  five:  {type:"mod5"},
  six:   {type:"setN", n:6},
  seven: {type:"self", op:"to70s"},
  eight: {type:"yn",   fn:x => x>=80},
  nine:  {type:"self", op:"times9"}
};
const QLABEL = {one:"ワン", two:"ツー", three:"スリー", four:"フォー", five:"ファイブ", six:"シックス", seven:"セブン", eight:"エイト", nine:"ナイン"};

/* ========= 状態 ========= */
const state = {
  turn: 0,
  turnStarter: "p1", // p1 or p2（＝先攻）
  asker: "p2",       // 後攻

  winTarget: 5,
  deuce: false,

  availableP1: new Set(),
  availableP2: new Set(),

  selP1: null, baseP1: null,
  selP2: null, baseP2: null,

  qKey: null, qAsker: null, qLocked: false,
  qSetN: [],
  qAnswerPrivate: null,

  revealed:false,
  score: {p1:0, p2:0, draw:0},
  history: {p1:[], p2:[]}
};

/* ========= DOM ========= */
const $ = s => document.querySelector(s);
const gridEl = $("#grid"), logEl = $("#log"), statusEl = $("#status");
const listOpponent = $("#listOpponent");
const badgeP1 = $("#badgeP1"), badgeP2 = $("#badgeP2");
const passNote = $("#passNote");
const setInput = $("#setInput");

/* ========= ユーティリティ ========= */
function log(line){ const div=document.createElement("div"); div.innerHTML=line; logEl.appendChild(div); logEl.scrollTop=logEl.scrollHeight; }
function numArrayDesc(set){ return Array.from(set).sort((a,b)=>b-a); }
function renderOpponent(){
  const oppSet = (state.turnStarter==="p1") ? state.availableP2 : state.availableP1;
  listOpponent.textContent = numArrayDesc(oppSet).join(", ");
}
function updateBadges(){
  const p1Text = state.baseP1!=null? `確定(${state.baseP1})` : (state.selP1?`選択中(${state.selP1})`:"未確定");
  const p2Text = state.baseP2!=null? `確定(${state.baseP2})` : (state.selP2?`選択中(${state.selP2})`:"未確定");
  badgeP1.textContent = `P1: ${p1Text}`; badgeP2.textContent = `P2: ${p2Text}`;
}
function renderGrid(){
  gridEl.innerHTML="";
  const who = currentPicker();
  const avail = (who==="p1")? state.availableP1 : state.availableP2;
  const sel  = (who==="p1")? state.selP1 : state.selP2;
  for(let n=100;n>=1;--n){
    const cell=document.createElement("div");
    cell.className="cell"; cell.textContent=n;
    const used = !avail.has(n);
    if(used){
      cell.classList.add("used");
    }else{
      cell.addEventListener("click", ()=>{
        if(state.revealed) return;
        if(who==="p1"){ state.selP1 = (state.selP1===n ? null : n); }
        else { state.selP2 = (state.selP2===n ? null : n); }
        renderGrid(); // 再描画で選択ハイライト更新
        updateBadges(); updateControls();
      });
      if(sel===n) cell.classList.add("selected");
    }
    gridEl.appendChild(cell);
  }
}
function updateScore(){ $("#sP1").textContent=state.score.p1; $("#sP2").textContent=state.score.p2; $("#sD").textContent=state.score.draw; }

/* ========= 先攻/後攻の識別 ========= */
function currentPicker(){ return state.turnStarter; } // 盤面操作中＝先攻
function currentAsker(){ return state.asker; }        // ライフナイン権利＝後攻

/* ========= 初期化 ========= */
function resetGame(){
  // 盤面リセット
  state.availableP1 = new Set(Array.from({length:100},(_,i)=>i+1));
  state.availableP2 = new Set(Array.from({length:100},(_,i)=>i+1));

  state.selP1=null; state.baseP1=null; state.selP2=null; state.baseP2=null;
  state.qKey=null; state.qAsker=null; state.qLocked=false; state.qSetN=[]; state.qAnswerPrivate=null;
  state.revealed=false; state.history={p1:[], p2:[]};
  state.score={p1:0, p2:0, draw:0}; state.deuce=false;

  // 先取・先手
  state.winTarget = parseInt($("#targetWins").value,10);
  $("#winTargetLabel").textContent = String(state.winTarget);

  const starterSel = $("#starter").value;
  state.turnStarter = (starterSel==="random") ? (Math.random()<0.5?"p1":"p2") : starterSel;
  state.asker = (state.turnStarter==="p1") ? "p2" : "p1";

  state.turn = 0; $("#turnNow").textContent = "0";
  logEl.innerHTML="";
  statusEl.textContent = "対局開始。先攻が数字を選び、後攻がライフナインを選択します。";
  updatePassNote();
  renderGrid(); renderOpponent(); updateScore(); updateBadges(); updateControls();
  nextTurn();
}

/* ========= 判定 ========= */
function judgeCore(a, b){
  const aOdd=(a%2===1), bOdd=(b%2===1);
  if(aOdd!==bOdd){ return aOdd? "A" : "B"; } // 奇数が勝ち（偶数は負け）
  const aM3=(a%3===0), bM3=(b%3===0);
  if(aM3 && bM3){ if(a<b) return "A"; if(a>b) return "B"; return "D"; }
  if(a>b) return "A"; if(a<b) return "B"; return "D";
}

/* ========= 自己変換 ========= */
function applySelfOp(num, op){
  if(num==null) return null;
  if(op==="plus2") return num + 2;
  if(op==="times9") return num * 9;
  if(op==="to70s") return 70 + (num % 10);
  return num;
}
function descSelf(op){
  if(op==="plus2") return "＋2";
  if(op==="times9") return "×9";
  if(op==="to70s") return "→70＋下一桁";
  return "";
}

/* ========= プレイヤー操作 ========= */
function lockStarterIfReady(){
  if(state.turnStarter==="p1"){ if(state.baseP1==null && state.selP1!=null){ state.baseP1 = state.selP1; } }
  else { if(state.baseP2==null && state.selP2!=null){ state.baseP2 = state.selP2; } }
}

/* ========= ライフナイン（後攻UI） ========= */
document.querySelectorAll(".qbtn").forEach(btn=>{
  btn.addEventListener("click", ()=>{
    if(state.revealed) return;
    // 後攻フェーズ（＝先攻の基底が確定している）でのみ選択可
    const starterBaseReady = (state.turnStarter==="p1") ? (state.baseP1!=null) : (state.baseP2!=null);
    if(!starterBaseReady) return;

    document.querySelectorAll(".qbtn").forEach(b=>b.classList.remove("chosen"));
    btn.classList.add("chosen");

    state.qKey = btn.dataset.q; state.qAsker = currentAsker();
    if(state.qKey==="six"){
      state.qSetN=[]; setInput.value=""; setInput.disabled=false;
      log(`<b>${whoLabel(state.qAsker)}の権利</b>: シックスを選択。集合を入力してください。`);
      state.qLocked = false; // 入力確定を待つ
    }else{
      previewQIfNeeded();
      state.qLocked = true;
      updateControls();
    }
  });
});

setInput.addEventListener("change", ()=>{
  if(state.revealed || state.qKey!=="six") return;
  const vals = setInput.value.trim().split(/\s+/).filter(s=>s.length>0).map(s=>parseInt(s,10)).filter(n=>Number.isInteger(n)&&n>=1&&n<=100);
  state.qSetN = [...new Set(vals)].slice(0,6);
  setInput.value = state.qSetN.join(" ");
  // 相手＝先攻の基底
  const target = (state.turnStarter==="p1") ? state.baseP2 : state.baseP1;
  const truth = new Set(state.qSetN).has(target);
  state.qAnswerPrivate = truth;
  log(`<b>${whoLabel(state.qAsker)}の質問: シックス</b> [${state.qSetN.join(", ")}] → <b>${truth? 'Yes':'No'}</b>（相手には非公開）`);
  state.qLocked = true;
  updateControls();
});

function previewQIfNeeded(){
  const def = QDEF[state.qKey]; if(!def) return;
  const target = (state.turnStarter==="p1") ? state.baseP2 : state.baseP1; // 相手＝先攻の基底
  if(def.type==="yn"){
    const truth = !!def.fn(target); state.qAnswerPrivate = truth;
    log(`<b>${whoLabel(state.qAsker)}の質問: ${QLABEL[state.qKey]}</b> → <b>${truth?'Yes':'No'}</b>（相手には非公開）`);
  }else if(def.type==="mod4"){
    const r=((target%4)+4)%4; state.qAnswerPrivate=r;
    log(`<b>${whoLabel(state.qAsker)}の質問: フォー</b> → <b>余り ${r}</b>（相手には非公開）`);
  }else if(def.type==="mod5"){
    const r=((target%5)+5)%5; state.qAnswerPrivate=r;
    log(`<b>${whoLabel(state.qAsker)}の質問: ファイブ</b> → <b>余り ${r}</b>（相手には非公開）`);
  }else{
    log(`<b>${whoLabel(state.qAsker)}の権利</b>: ${QLABEL[state.qKey]} を選択（効果は公開時に適用）`);
  }
}

function whoLabel(w){ return w==="p1"? "P1" : "P2"; }

/* ========= ターン制御 ========= */
function nextTurn(){
  state.turn += 1; $("#turnNow").textContent = String(state.turn);

  if(state.turn===1){
    const starterSel=$("#starter").value; state.turnStarter = (starterSel==="random") ? (Math.random()<0.5?"p1":"p2") : starterSel;
  }else{
    state.turnStarter = (state.turnStarter==="p1") ? "p2" : "p1";
  }
  state.asker = (state.turnStarter==="p1") ? "p2" : "p1";
  $("#turnStarter").textContent = (state.turnStarter==="p1") ? "P1" : "P2";
  $("#asker").textContent = (state.asker==="p1") ? "P1" : "P2";

  state.selP1=null; state.baseP1=null; state.selP2=null; state.baseP2=null;
  state.qKey=null; state.qAsker=null; state.qLocked=false; state.qSetN=[]; state.qAnswerPrivate=null;
  state.revealed=false;

  Array.from(gridEl.children).forEach(c=>c.classList.remove("selected"));

  updatePassNote();
  renderGrid(); renderOpponent(); updateBadges(); updateControls();
}

function updatePassNote(){ passNote.innerHTML = `— 今は <b>${(state.turnStarter==="p1"?"P1":"P2")}</b> のターンです —`; }

/* ========= 公開（処理） ========= */
function revealAndJudge(){
  if(state.revealed) return;

  // 先攻ロック（必要なら自動確定）
  lockStarterIfReady();

  // 後攻の選択を確定（未確定で選択のみなら基底へ）
  const follower = (state.turnStarter==="p1")? "p2" : "p1";
  if(follower==="p2"){ if(state.baseP2==null && state.selP2!=null) state.baseP2 = state.selP2; }
  else { if(state.baseP1==null && state.selP1!=null) state.baseP1 = state.selP1; }

  if(state.baseP1==null || state.baseP2==null){ alert("両者の数字を選んでください。"); return; }

  // 公開ログ（質問結果の開示）
  if(state.qAsker){
    const def = QDEF[state.qKey];
    if(def){
      if(def.type==="yn"){ log(`<b>${whoLabel(state.qAsker)}の質問: ${QLABEL[state.qKey]}</b> → <b>${state.qAnswerPrivate?'Yes':'No'}</b>`); }
      else if(def.type==="mod4"){ log(`<b>${whoLabel(state.qAsker)}の質問: フォー</b> → <b>余り ${state.qAnswerPrivate}</b>`); }
      else if(def.type==="mod5"){ log(`<b>${whoLabel(state.qAsker)}の質問: ファイブ</b> → <b>余り ${state.qAnswerPrivate}</b>`); }
      else if(def.type==="setN"){ log(`<b>${whoLabel(state.qAsker)}の質問: シックス</b> [${state.qSetN.join(", ")}] → <b>${state.qAnswerPrivate?'Yes':'No'}</b>`); }
      else if(def.type==="self"){ log(`<b>${whoLabel(state.qAsker)}の権利: ${QLABEL[state.qKey]}</b>（効果はこれから自分の数に適用）`); }
      else if(def.type==="rule"){ log(`<b>${whoLabel(state.qAsker)}の権利: ${QLABEL[state.qKey]}</b>（判定はこれから適用）`); }
    }
  }

  // 自己変換適用（後攻側にのみ）
  let a = state.baseP1, b = state.baseP2; // A=P1, B=P2
  const def = QDEF[state.qKey] || null;
  if(def && def.type==="self"){
    if(state.qAsker==="p1"){ a = applySelfOp(a, def.op); log(`<b>P1の権利: ${QLABEL[state.qKey]}</b> → 自分の数 ${descSelf(def.op)} = <b>${a}</b>`); }
    else if(state.qAsker==="p2"){ b = applySelfOp(b, def.op); log(`<b>P2の権利: ${QLABEL[state.qKey]}</b> → 自分の数 ${descSelf(def.op)} = <b>${b}</b>`); }
  }

  // ワン（後攻のみ有効）
  function resolveWithOne(aBase,bBase){
    const follower = (state.turnStarter==="p1")? "p2" : "p1";
    if(def && state.qKey==="one"){
      const askerIsP1 = (state.qAsker==="p1");
      const askerNum  = askerIsP1? aBase : bBase;
      const otherNum  = askerIsP1? bBase : aBase;
      if(askerNum>=1 && askerNum<=9 && (askerNum%10)===(otherNum%10)){
        return askerIsP1? "A" : "B";
      }
    }
    return null;
  }

  let res = resolveWithOne(a,b);
  if(!res){ res = judgeCore(a,b); }

  if(res==="A") state.score.p1++; else if(res==="B") state.score.p2++; else state.score.draw++;
  log(`<b>[公開]</b> P1=${a} / P2=${b} → <b>${res==="A"?"P1勝ち":res==="B"?"P2勝ち":"引分"}</b>`);
  updateScore();

  state.revealed = true;
  statusEl.textContent = "判定完了。数字は自動で削除されます。";
  cleanup();
}

/* ========= 先取＋デュース ========= */
function maybeFinishByTarget(){
  const P1=state.score.p1, P2=state.score.p2, T=state.winTarget;

  if(!state.deuce){
    if(P1>=T && P2>=T){ state.deuce = true; log(`<b>=== デュース突入（Win by 2） ===</b>`); return false; }
    if((P1>=T || P2>=T) && Math.abs(P1-P2)===1){ return false; }
    if((P1>=T || P2>=T) && Math.abs(P1-P2)>=2){ endGame(); return true; }
    return false;
  }
  if(Math.abs(P1-P2)>=2){ endGame(); return true; }
  return false;
}

function cleanup(){
  if(state.baseP1!=null && state.availableP1.has(state.baseP1)) state.availableP1.delete(state.baseP1);
  if(state.baseP2!=null && state.availableP2.has(state.baseP2)) state.availableP2.delete(state.baseP2);

  if(state.baseP1!=null) state.history.p1.push(state.baseP1);
  if(state.baseP2!=null) state.history.p2.push(state.baseP2);

  renderGrid(); renderOpponent(); updateBadges();

  if(!maybeFinishByTarget()) nextTurn();
}

function endGame(){
  const msg = `最終スコア：P1 ${state.score.p1} - ${state.score.p2} P2`;
  statusEl.textContent = msg + (state.deuce ? "（デュースの末）" : "") + "　新しい対局で再開できます。";
  log(`<b>=== 終局 ===</b> ${msg}${state.deuce ? "（デュースの末）" : ""}`);
}

/* ========= コントロール活性制御 ========= */
function updateControls(){
  // 先攻決定活性：先攻の選択があり基底が未確定のとき
  const canLock = !state.revealed && (
    (state.turnStarter==="p1" && state.baseP1==null && state.selP1!=null) ||
    (state.turnStarter==="p2" && state.baseP2==null && state.selP2!=null)
  );
  $("#btnLock").disabled = !canLock;

  // 後攻決定活性：条件（後攻フェーズ中 && 後攻の数字選択済み/確定 && ライフナイン確定）
  const starterLocked = (state.turnStarter==="p1") ? (state.baseP1!=null) : (state.baseP2!=null);
  const follower = (state.turnStarter==="p1")? "p2" : "p1";
  const followerHasPick = (follower==="p1") ? (state.baseP1!=null || state.selP1!=null) : (state.baseP2!=null || state.selP2!=null);
  const canReveal = !state.revealed && starterLocked && followerHasPick && (state.qKey!=null && state.qLocked===true);
  $("#btnReveal").disabled = !canReveal;

  // ライフナイン活性：先攻の基底が確定したらON（＝後攻フェーズ）
  const qEnable = starterLocked && !state.revealed;
  document.querySelectorAll(".qbtn").forEach(b=>b.disabled = !qEnable || state.qLocked);
  setInput.disabled = !(qEnable && state.qKey==="six" && !state.qLocked);

  updateBadges();
}

/* ========= イベント ========= */
$("#btnLock").addEventListener("click", ()=>{
  if(state.revealed) return;
  lockStarterIfReady();
  updatePassNote(); updateControls();
});
$("#btnReveal").addEventListener("click", revealAndJudge);
$("#btnNew").addEventListener("click", resetGame);

/* 初期起動 */
resetGame();
</script>
</body>
</html>
