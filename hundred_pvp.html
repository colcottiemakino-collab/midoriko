<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ハンドレッド / Hundred PvP ver 3.2.2</title>
<style>
  :root{
    --bg:#0e1a12; --bg2:#122216; --panel:#152a1b; --accent:#35c46e; --accent-2:#2aa55b;
    --text:#e7ffe7; --muted:#b9d8c0; --warn:#ffd37a; --bad:#ff8a8a; --good:#8affb9;
    --grid-used:#2a3a2f; --btn:#173d26; --btn-hover:#1f5333; --border:#2f6848;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    background: linear-gradient(180deg,var(--bg) 0%, var(--bg2) 300px, var(--bg2) 100%) no-repeat fixed;
    color:var(--text);
    font-family:ui-sans-serif,system-ui,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif;
  }
  header{padding:18px 20px; border-bottom:1px solid var(--border); display:flex; gap:12px; align-items:baseline; flex-wrap:wrap}
  h1{margin:0; font-size:20px; letter-spacing:.08em; color:var(--accent)}
  main{display:grid; grid-template-columns: 1fr; gap:12px; padding:12px}

  .wrap{display:grid; grid-template-columns: 1fr; gap:12px}
  @media (min-width: 980px){ .wrap{grid-template-columns: 420px 1fr 420px} }

  .card{background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:14px;
    box-shadow: 0 10px 20px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.04);}
  .card h2{margin:0 0 10px; font-size:16px; color:var(--accent)}
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  select, button, input{
    background:var(--btn); color:var(--text); border:1px solid var(--border);
    border-radius:10px; padding:10px 12px; font-size:16px; touch-action:manipulation;
  }
  input{width:240px}
  button:hover{background:var(--btn-hover)}
  button:disabled{opacity:.45; cursor:not-allowed}
  .accent{background:var(--accent-2); border-color:transparent; color:#04210f; font-weight:700}
  .accent:hover{filter:brightness(1.05)}
  .muted{color:var(--muted); font-size:12px}

  .grid{display:grid; grid-template-columns: repeat(10, minmax(0,1fr)); gap:6px}
  .cell{
    padding:10px 0; text-align:center; border-radius:10px; border:1px solid var(--border);
    user-select:none; cursor:pointer; background:#13301e; transition:transform .05s ease, background .15s ease;
    font-variant-numeric:tabular-nums; font-size:14px;
  }
  .cell:hover{transform:translateY(-1px); background:#184029}
  .cell.used{background:var(--grid-used); color:#6e8a78; border-style:dashed; cursor:not-allowed}
  .cell.selected{outline:2px solid var(--accent); box-shadow:0 0 0 2px rgba(53,196,110,.25) inset}

  .log{max-height:420px; overflow:auto; font-family:ui-monospace,Consolas,monospace; font-size:12px; line-height:1.5}
  .log b{color:var(--good)}
  .listbox{max-height:240px; overflow:auto; background:#0f2016; border:1px solid var(--border); border-radius:10px; padding:8px}
  .sep{border-top:1px solid var(--border); margin:10px 0; opacity:.5}

  .qbar button{padding:8px 10px; font-size:14px}
  .qbar .chosen{outline:2px solid var(--accent)}
  .qline{display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:6px}
  .hint{font-size:12px; color:#cfe9d5}

  .badge{display:inline-block; padding:4px 10px; border-radius:999px; border:1px solid var(--border); background:#0f2016; font-size:12px; color:#cfe9d5}

  .who{font-weight:700; color:var(--warn)}
  .pass{display:block; text-align:center; padding:8px; border:1px dashed var(--border); border-radius:10px; margin-top:6px}
</style>
</head>
<body>
<header>
  <h1>ハンドレッド / Hundred PvP ver 3.2.2（人間×人間／1台交互）</h1>
</header>

<main>
  <section class="card">
    <h2>セットアップ</h2>
    <div class="row" style="margin-bottom:8px">
      <label>先取本数</label>
      <select id="targetWins">
        <option value="5" selected>5</option>
        <option value="9">9</option>
        <option value="13">13</option>
      </select>
      <label>先攻</label>
      <select id="starter">
        <option value="p1" selected>プレイヤー1</option>
        <option value="p2">プレイヤー2</option>
        <option value="random">ランダム（初回のみ／以降交互）</option>
      </select>
      <button id="btnNew" class="accent">新しい対局</button>
    </div>
    <div id="status" class="muted">対局を開始してください。</div>
  </section>

  <div class="wrap">
    <section class="card">
      <h2>ターン／進行</h2>
      <div class="row" style="margin-bottom:8px">
        <div>ターン：<span id="turnNow">-</span>　
          先攻：<span id="turnStarter">-</span>　
          後攻：<span id="asker">-</span></div>
      </div>
      <div class="row" style="margin-bottom:8px">
        <div>スコア（先取 <span id="winTargetLabel">5</span>）：P1 <span id="sP1">0</span> - <span id="sP2">0</span> P2　（引分 <span id="sD">0</span>）</div>
      </div>

      <div class="row" style="gap:12px">
        <span class="badge" id="badgeP1">P1: 未確定</span>
        <span class="badge" id="badgeP2">P2: 未確定</span>
      </div>

      <div class="sep"></div>

      <h2>後攻の権利（ライフナイン）</h2>
      <div class="muted">後攻プレイヤーだけが毎ターン1つ使えます（質問系は先に後攻だけ結果が見えます）。</div>
      <div class="row qbar" style="margin-top:8px">
        <button class="qbtn" data-q="one" disabled>ワン</button>
        <button class="qbtn" data-q="two" disabled>ツー</button>
        <button class="qbtn" data-q="three" disabled>スリー</button>
        <button class="qbtn" data-q="four" disabled>フォー</button>
        <button class="qbtn" data-q="five" disabled>ファイブ</button>
        <button class="qbtn" data-q="six" disabled>シックス</button>
        <button class="qbtn" data-q="seven" disabled>セブン</button>
        <button class="qbtn" data-q="eight" disabled>エイト</button>
        <button class="qbtn" data-q="nine" disabled>ナイン</button>
      </div>
      <div class="qline">
        <label for="setInput" class="hint">シックス用（1〜100の数字を<b>最大6つ</b>、空白区切り）</label>
        <input id="setInput" placeholder="例: 17 33 70 98 41 12" disabled />
      </div>

      <div class="row" style="margin-top:8px">
        <button id="btnLock" class="accent">先攻決定</button>
        <button id="btnReveal" class="accent" disabled>後攻決定</button>
      </div>
      <div class="pass" id="passNote">— 今は <span class="who">P1</span>（先攻）のターンです —</div>
    </section>

    <section class="card">
      <h2>盤面（いま操作中の人の未使用）</h2>
      <div id="grid" class="grid"></div>
    </section>

    <section class="card">
      <h2>相手情報</h2>
      <div class="muted">右の一覧は<b>相手の未使用数字</b>。先攻/後攻やフェーズの入替に合わせて自動で切り替わります。</div>
      <div class="sep"></div>
      <div><b>相手未使用（=残り）</b></div>
      <div id="listOpponent" class="listbox"></div>
      <div class="sep"></div>
      <h2>ログ</h2>
      <div id="log" class="log"></div>
    </section>
  </div>

  <section class="card">
    <h2>ルール（要点）</h2>
    <pre class="rules-raw">
【基本ルール】
あなたとAIは、それぞれ1～100の数字カードを持っています。
先攻後攻ともに、数字カードを１つ伏せて出します。
せーのでめくって、数字がでかい方の勝ちです。
同じだったら引き分けになります。
１度使ったカードはもう使えません。

これを先攻後攻を交代しながら、先に決まった回数勝利すれば勝ちです。
ただしリードが１差のままでは決着せず、
両者が先取本数に到達（例：5-5）するとデュース（Win by 2）になります。

【応用ルール】
(1)すべての偶数は、すべての奇数に負けます。あらゆるルールに優先します。
(2)お互い３の倍数だった場合にかぎり、「より小さい方」が勝ちます。
　このルールは(1)より弱いです。
　９９と３なら３の勝ちですが、９９と６は９９の勝ちです。奇数なので。
(3)後述する「ワン」を利用した場合、成功すれば「ワン」が勝ちます。

【ライフナイン（後攻専用）】
後攻側プレイヤーは「ライフナイン」と呼ばれる９つの権利があります。
以下の中から、毎回どれか１つだけを使うことができます。

ワン    あなたが１～９を出し、相手の下1桁と一致したらあなたの勝利。
ツー    あなたの選んだ自分の数を +２する（上限なし）。変換先が使用済みでも使える。
スリー  相手が３の倍数か聞ける（Yes/No）
フォー  相手の数を４で割った余り（0〜3）を聞ける
ファイブ 相手の数を５で割った余り（0〜4）を聞ける
シックス あなたが最大６つの数字を指定し、そのいずれかかどうかを聞ける（Yes/No）
セブン  あなたの数字の「10 の位」を７にする（例: 53→73）。変換先が使用済みでも使える。
エイト  相手が80以上かどうかを聞ける（Yes/No）
ナイン  あなたの選んだ自分の数を９倍にする（上限なし）。変換先が使用済みでも使える。
</pre>
  </section>
</main>

<script>
/* ========= 定義 ========= */
const QDEF = {
  one:   {type:"rule"},
  two:   {type:"self", op:"plus2"},
  three: {type:"yn",   fn:x => x%3===0},
  four:  {type:"mod4"},
  five:  {type:"mod5"},
  six:   {type:"setN", n:6},
  seven: {type:"self", op:"to70s"},
  eight: {type:"yn",   fn:x => x>=80},
  nine:  {type:"self", op:"times9"}
};
const QLABEL = {one:"ワン", two:"ツー", three:"スリー", four:"フォー", five:"ファイブ", six:"シックス", seven:"セブン", eight:"エイト", nine:"ナイン"};

/* ========= 状態 ========= */
const state = {
  turn: 0,
  initialStarter: "p1",
  turnStarter: "p1", // そのターンの先攻
  asker: "p2",       // そのターンの後攻
  phase: "starter",  // "starter"（先攻の思考/選択中） or "follower"（後攻の思考/選択中）

  winTarget: 5,
  deuce: false,

  availableP1: new Set(),
  availableP2: new Set(),

  selP1: null, baseP1: null,
  selP2: null, baseP2: null,

  qKey: null, qAsker: null, qLocked: false,
  qSetN: [],
  qAnswerPrivate: null,

  revealed:false,
  score: {p1:0, p2:0, draw:0},
  history: {p1:[], p2:[]}
};

/* ========= DOM ========= */
const $ = s => document.querySelector(s);
const gridEl = $("#grid"), logEl = $("#log"), statusEl = $("#status");
const listOpponent = $("#listOpponent");
const badgeP1 = $("#badgeP1"), badgeP2 = $("#badgeP2");
const passNote = $("#passNote");
const setInput = $("#setInput");

/* ========= ユーティリティ ========= */
function log(line){ const div=document.createElement("div"); div.innerHTML=line; logEl.appendChild(div); logEl.scrollTop=logEl.scrollHeight; }
function numArrayDesc(set){ return Array.from(set).sort((a,b)=>b-a); }

/* 操作中の側 */
function currentActor(){
  if(state.phase==="starter") return state.turnStarter;
  return state.turnStarter==="p1" ? "p2" : "p1";
}
function otherOf(w){ return w==="p1"?"p2":"p1"; }

/* ========= レンダリング ========= */
function renderOpponent(){
  const actor = currentActor();
  const oppSet = (actor==="p1") ? state.availableP2 : state.availableP1;
  if(listOpponent) listOpponent.textContent = numArrayDesc(oppSet).join(", ");
}
function updateBadges(){
  const p1Text = state.baseP1!=null? `確定(${state.baseP1})` : (state.selP1?`選択中(${state.selP1})`:"未確定");
  const p2Text = state.baseP2!=null? `確定(${state.baseP2})` : (state.selP2?`選択中(${state.selP2})`:"未確定");
  badgeP1.textContent = `P1: ${p1Text}`; badgeP2.textContent = `P2: ${p2Text}`;
}
function renderGrid(){
  gridEl.innerHTML="";
  const who = currentActor();
  const avail = (who==="p1")? state.availableP1 : state.availableP2;
  for(let n=100;n>=1;--n){
    const cell=document.createElement("div");
    cell.className="cell"; cell.textContent=n;
    const used = !avail.has(n);
    if(used){
      cell.classList.add("used");
    }else{
      cell.addEventListener("click", ()=>{
        if(state.revealed) return;
        if(who==="p1"){ state.selP1 = (state.selP1===n ? null : n); }
        else { state.selP2 = (state.selP2===n ? null : n); }
        Array.from(gridEl.children).forEach(c=>c.classList.remove("selected"));
        const sel = (who==="p1")? state.selP1 : state.selP2;
        if(sel===n) cell.classList.add("selected");
        updateBadges(); updateControls();
      });
    }
    gridEl.appendChild(cell);
  }
}
function updateScore(){ $("#sP1").textContent=state.score.p1; $("#sP2").textContent=state.score.p2; $("#sD").textContent=state.score.draw; }

/* ========= ターン開始/遷移 ========= */
function startTurn(){
  state.turn += 1; $("#turnNow").textContent = String(state.turn);

  if(state.turn===1){
    state.turnStarter = state.initialStarter;
  }else{
    state.turnStarter = otherOf(state.turnStarter);
  }
  state.asker = otherOf(state.turnStarter);
  state.phase = "starter";

  $("#turnStarter").textContent = (state.turnStarter==="p1") ? "P1" : "P2";
  $("#asker").textContent = (state.asker==="p1") ? "P1" : "P2";

  state.selP1=null; state.baseP1=null; state.selP2=null; state.baseP2=null;
  state.qKey=null; state.qAsker=null; state.qLocked=false; state.qSetN=[]; state.qAnswerPrivate=null;
  state.revealed=false;

  Array.from(gridEl.children).forEach(c=>c.classList.remove("selected"));

  if(state.deuce){ statusEl.textContent = "デュース中（Win by 2）。先攻→後攻の順で操作してください。"; }
  else if(state.turn===1){ statusEl.textContent = `対局開始。先取本数は ${state.winTarget}。`; }

  updatePassNote();
  renderGrid(); renderOpponent(); updateBadges(); updateControls();
}

function updatePassNote(){
  const actor = currentActor();
  const role = (actor===state.turnStarter) ? "先攻" : "後攻";
  passNote.innerHTML = `— 今は <span class="who">${actor==="p1"?"P1":"P2"}</span>（${role}）のターンです —`;
}

/* ========= 初期化 ========= */
function resetGame(){
  state.availableP1 = new Set(Array.from({length:100},(_,i)=>i+1));
  state.availableP2 = new Set(Array.from({length:100},(_,i)=>i+1));

  state.selP1=null; state.baseP1=null; state.selP2=null; state.baseP2=null;
  state.qKey=null; state.qAsker=null; state.qLocked=false; state.qSetN=[]; state.qAnswerPrivate=null;
  state.revealed=false; state.history={p1:[], p2:[]};
  state.score={p1:0, p2:0, draw:0}; state.deuce=false;

  state.winTarget = parseInt($("#targetWins").value,10);
  $("#winTargetLabel").textContent = String(state.winTarget);

  // 初回の先攻だけここで決定（以降は交互）
  const starterSel = $("#starter").value;
  state.initialStarter = (starterSel==="random") ? (Math.random()<0.5?"p1":"p2") : starterSel;
  state.turn = 0;

  logEl.innerHTML="";
  statusEl.textContent = "対局開始。先攻が数字を選び、後攻がライフナインを選択します。";

  startTurn(); // ターン1へ
}

/* ========= 判定 ========= */
function judgeCore(a, b){
  const aOdd = (a%2===1), bOdd = (b%2===1);
  if(aOdd!==bOdd){ return aOdd? "A" : "B"; }
  const aM3=(a%3===0), bM3=(b%3===0);
  if(aM3 && bM3){ if(a<b) return "A"; if(a>b) return "B"; return "D"; }
  if(a>b) return "A"; if(a<b) return "B"; return "D";
}

/* ========= 自己変換 ========= */
function applySelfOp(num, op){
  if(num==null) return null;
  if(op==="plus2") return num + 2;
  if(op==="times9") return num * 9;
  if(op==="to70s") return 70 + (num % 10);
  return num;
}
function descSelf(op){
  if(op==="plus2") return "＋2";
  if(op==="times9") return "×9";
  if(op==="to70s") return "→70＋下一桁";
  return "";
}

/* ========= ライフナイン UI ========= */
const qButtons = document.querySelectorAll(".qbtn");
qButtons.forEach(btn=>{
  btn.addEventListener("click", ()=>{
    if(state.revealed) return;
    if(state.phase!=="follower") return; // 後攻フェーズのみ
    // 後攻側から見た先攻の基底が必要
    if(state.asker==="p1" && state.baseP2==null) return;
    if(state.asker==="p2" && state.baseP1==null) return;
    if(state.qLocked) return;

    qButtons.forEach(b=>b.classList.remove("chosen"));
    btn.classList.add("chosen");

    state.qKey = btn.dataset.q; state.qAsker = state.asker;
    if(state.qKey==="six"){
      state.qSetN=[]; setInput.value=""; setInput.disabled=false;
      log(`<b>${whoLabel(state.qAsker)}の権利</b>: シックスを選択。集合を入力してください。`);
    }else{
      evalQuestionPreview();
      state.qLocked = true; updateControls();
    }
  });
});

setInput.addEventListener("change", ()=>{
  if(state.revealed || state.qKey!=="six" || state.qLocked===true) return;
  const vals = setInput.value.trim().split(/\s+/).filter(s=>s.length>0).map(s=>parseInt(s,10)).filter(n=>Number.isInteger(n)&&n>=1&&n<=100);
  state.qSetN = [...new Set(vals)].slice(0,6);
  setInput.value = state.qSetN.join(" ");
  const target = (state.qAsker==="p1") ? state.baseP2 : state.baseP1;
  const truth = new Set(state.qSetN).has(target);
  state.qAnswerPrivate = truth;
  log(`<b>${whoLabel(state.qAsker)}の質問: シックス</b> [${state.qSetN.join(", ")}] → <b>${truth? 'Yes':'No'}</b>（相手には非公開）`);
  state.qLocked = true; updateControls();
});

function evalQuestionPreview(){
  const def = QDEF[state.qKey]; if(!def) return;
  const target = (state.qAsker==="p1") ? state.baseP2 : state.baseP1;
  if(def.type==="yn"){
    const truth = !!def.fn(target); state.qAnswerPrivate = truth;
    log(`<b>${whoLabel(state.qAsker)}の質問: ${QLABEL[state.qKey]}</b> → <b>${truth?'Yes':'No'}</b>（相手には非公開）`);
  }else if(def.type==="mod4"){
    const r=((target%4)+4)%4; state.qAnswerPrivate=r;
    log(`<b>${whoLabel(state.qAsker)}の質問: フォー</b> → <b>余り ${r}</b>（相手には非公開）`);
  }else if(def.type==="mod5"){
    const r=((target%5)+5)%5; state.qAnswerPrivate=r;
    log(`<b>${whoLabel(state.qAsker)}の質問: ファイブ</b> → <b>余り ${r}</b>（相手には非公開）`);
  }else{
    log(`<b>${whoLabel(state.qAsker)}の権利</b>: ${QLABEL[state.qKey]} を選択（効果は公開時に適用）`);
  }
}
function whoLabel(w){ return w==="p1"? "P1" : "P2"; }

/* ========= 決定系 ========= */
$("#btnLock").addEventListener("click", ()=>{
  if(state.revealed) return;
  if(state.phase!=="starter") return;

  const starter = state.turnStarter;
  if(starter==="p1"){
    if(state.selP1==null){ alert("P1（先攻）の数字を選んでください。"); return; }
    state.baseP1 = state.selP1; log("<b>P1（先攻）が数字を確定</b>");
  }else{
    if(state.selP2==null){ alert("P2（先攻）の数字を選んでください。"); return; }
    state.baseP2 = state.selP2; log("<b>P2（先攻）が数字を確定</b>");
  }

  // 後攻フェーズへ遷移
  state.phase = "follower";
  updatePassNote(); updateControls(); renderOpponent();
});

$("#btnReveal").addEventListener("click", ()=>{
  if(state.revealed) return;
  if(state.phase!=="follower") return;

  // 後攻の数を確定（未確定なら選択値で確定）
  const follower = otherOf(state.turnStarter);
  if(follower==="p1"){
    if(state.baseP1==null){
      if(state.selP1==null){ alert("P1（後攻）の数字を選んでください。"); return; }
      state.baseP1 = state.selP1;
    }
  }else{
    if(state.baseP2==null){
      if(state.selP2==null){ alert("P2（後攻）の数字を選んでください。"); return; }
      state.baseP2 = state.selP2;
    }
  }

  revealAndJudge();
});

/* ========= 公開（判定） ========= */
function revealAndJudge(){
  if(state.baseP1==null || state.baseP2==null){ alert("両者の数字を選んでください。"); return; }

  // 公開時に質問結果を開示（質問系のみ）
  if(state.qAsker){
    const def = QDEF[state.qKey];
    if(def){
      if(def.type==="yn"){ log(`<b>${whoLabel(state.qAsker)}の質問: ${QLABEL[state.qKey]}</b> → <b>${state.qAnswerPrivate?'Yes':'No'}</b>`); }
      else if(def.type==="mod4"){ log(`<b>${whoLabel(state.qAsker)}の質問: フォー</b> → <b>余り ${state.qAnswerPrivate}</b>`); }
      else if(def.type==="mod5"){ log(`<b>${whoLabel(state.qAsker)}の質問: ファイブ</b> → <b>余り ${state.qAnswerPrivate}</b>`); }
      else if(def.type==="setN"){ log(`<b>${whoLabel(state.qAsker)}の質問: シックス</b> [${state.qSetN.join(", ")}] → <b>${state.qAnswerPrivate?'Yes':'No'}</b>`); }
      else if(def.type==="self"){ log(`<b>${whoLabel(state.qAsker)}の権利: ${QLABEL[state.qKey]}</b>（効果はこれから自分の数に適用）`); }
      else if(def.type==="rule"){ log(`<b>${whoLabel(state.qAsker)}の権利: ${QLABEL[state.qKey]}</b>（判定はこれから適用）`); }
    }
  }

  // 自己変換（後攻の数に適用）
  let a = state.baseP1, b = state.baseP2; // A=P1, B=P2
  const def = QDEF[state.qKey] || null;
  if(def && def.type==="self"){
    if(state.qAsker==="p1"){ a = applySelfOp(a, def.op); log(`<b>P1（後攻）の権利: ${QLABEL[state.qKey]}</b> → 自分の数 ${descSelf(def.op)} = <b>${a}</b>`); }
    else if(state.qAsker==="p2"){ b = applySelfOp(b, def.op); log(`<b>P2（後攻）の権利: ${QLABEL[state.qKey]}</b> → 自分の数 ${descSelf(def.op)} = <b>${b}</b>`); }
  }

  // ワン（後攻のみ有効）
  function resolveWithOne(aBase,bBase){
    if(def && state.qKey==="one"){
      const askerIsP1 = (state.qAsker==="p1");
      const askerNum  = askerIsP1? aBase : bBase;
      const otherNum  = askerIsP1? bBase : aBase;
      if(askerNum>=1 && askerNum<=9 && (askerNum%10)===(otherNum%10)){
        return askerIsP1? "A" : "B";
      }
    }
    return null;
  }

  let res = resolveWithOne(a,b);
  if(!res){ res = judgeCore(a,b); }

  if(res==="A") state.score.p1++; else if(res==="B") state.score.p2++; else state.score.draw++;
  log(`<b>[公開]</b> P1=${a} / P2=${b} → <b>${res==="A"?"P1勝ち":res==="B"?"P2勝ち":"引分"}</b>`);
  updateScore();

  state.revealed = true;
  statusEl.textContent = "判定完了。数字は自動で削除されます。";
  cleanup();
}

/* ========= 先取＋デュース ========= */
function maybeFinishByTarget(){
  const P1=state.score.p1, P2=state.score.p2, T=state.winTarget;

  if(!state.deuce){
    if(P1>=T && P2>=T){ state.deuce = true; log(`<b>=== デュース突入（Win by 2） ===</b>`); return false; }
    if((P1>=T || P2>=T) && Math.abs(P1-P2)===1){ return false; }
    if((P1>=T || P2>=T) && Math.abs(P1-P2)>=2){ endGame(); return true; }
    return false;
  }
  if(Math.abs(P1-P2)>=2){ endGame(); return true; }
  return false;
}

function cleanup(){
  if(state.baseP1!=null && state.availableP1.has(state.baseP1)) state.availableP1.delete(state.baseP1);
  if(state.baseP2!=null && state.availableP2.has(state.baseP2)) state.availableP2.delete(state.baseP2);

  if(state.baseP1!=null) state.history.p1.push(state.baseP1);
  if(state.baseP2!=null) state.history.p2.push(state.baseP2);

  // 次ターンへ
  if(!maybeFinishByTarget()){
    renderGrid(); renderOpponent(); updateBadges();
    startTurn();
  }
}

function endGame(){
  const msg = `最終スコア：P1 ${state.score.p1} - ${state.score.p2} P2`;
  statusEl.textContent = msg + (state.deuce ? "（デュースの末）" : "") + "　新しい対局で再開できます。";
  log(`<b>=== 終局 ===</b> ${msg}${state.deuce ? "（デュースの末）" : ""}`);
  // ここで止める（startTurnしない）
}

/* ========= コントロール活性 ========= */
function updateControls(){
  // 後攻の権利は、先攻の基底が確定してから & 後攻フェーズで有効
  const qEnable = (!state.revealed && state.phase==="follower" && (
    (state.asker==="p1" && state.baseP2!=null) || (state.asker==="p2" && state.baseP1!=null)
  ));
  document.querySelectorAll(".qbtn").forEach(b=>b.disabled = !qEnable || state.qLocked);
  setInput.disabled = !(qEnable && state.qKey==="six" && !state.qLocked);

  // 先攻決定（先攻フェーズで、先攻が選択済みか）
  const actor = currentActor();
  const canLock = (!state.revealed && state.phase==="starter" && (
    (actor==="p1" && state.selP1!=null) || (actor==="p2" && state.selP2!=null)
  ));
  $("#btnLock").disabled = !canLock;

  // 後攻決定（後攻フェーズで、先攻は確定済み＋後攻は選択 or 確定済み）＆質問があれば確定済み
  const follower = otherOf(state.turnStarter);
  const followerReady = (follower==="p1") ? (state.baseP1!=null || state.selP1!=null) : (state.baseP2!=null || state.selP2!=null);
  const qOk = (state.qKey==null) || (state.qLocked===true);
  const canReveal = (!state.revealed && state.phase==="follower" &&
                     ((state.turnStarter==="p1" ? state.baseP1!=null : state.baseP2!=null)) &&
                     followerReady && qOk);
  $("#btnReveal").disabled = !canReveal;

  updatePassNote();
  updateBadges();
  renderOpponent();
}

/* ========= 初期イベント ========= */
$("#btnNew").addEventListener("click", resetGame);
document.querySelectorAll(".qbtn"); // already wired above

/* 起動 */
resetGame();
</script>
</body>
</html>
